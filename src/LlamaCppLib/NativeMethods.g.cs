// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace LLamaCppLib
{
    internal static unsafe partial class NativeMethods
    {
        const string __DllName = "llama";



        [DllImport(__DllName, EntryPoint = "renameat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int renameat(int arg1, byte* arg2, int arg3, byte* arg4);

        [DllImport(__DllName, EntryPoint = "renamex_np", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int renamex_np(byte* arg1, byte* arg2, uint arg3);

        [DllImport(__DllName, EntryPoint = "renameatx_np", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int renameatx_np(int arg1, byte* arg2, int arg3, byte* arg4, uint arg5);

        [DllImport(__DllName, EntryPoint = "clearerr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void clearerr(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "fclose", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fclose(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "feof", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int feof(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "ferror", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ferror(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "fflush", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fflush(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "fgetc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fgetc(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "fgetpos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fgetpos(__sFILE* arg1, long* arg2);

        [DllImport(__DllName, EntryPoint = "fgets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* fgets(byte* arg1, int arg2, __sFILE* arg3);

        [DllImport(__DllName, EntryPoint = "fopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* fopen(byte* __filename, byte* __mode);

        [DllImport(__DllName, EntryPoint = "fprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fprintf(__sFILE* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "fputc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fputc(int arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "fputs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fputs(byte* arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "fread", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CULong fread(void* __ptr, CULong __size, CULong __nitems, __sFILE* __stream);

        [DllImport(__DllName, EntryPoint = "freopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* freopen(byte* arg1, byte* arg2, __sFILE* arg3);

        [DllImport(__DllName, EntryPoint = "fscanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fscanf(__sFILE* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "fseek", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fseek(__sFILE* arg1, CLong arg2, int arg3);

        [DllImport(__DllName, EntryPoint = "fsetpos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fsetpos(__sFILE* arg1, long* arg2);

        [DllImport(__DllName, EntryPoint = "ftell", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CLong ftell(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "fwrite", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CULong fwrite(void* __ptr, CULong __size, CULong __nitems, __sFILE* __stream);

        [DllImport(__DllName, EntryPoint = "getc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int getc(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "getchar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int getchar();

        [DllImport(__DllName, EntryPoint = "gets", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gets(byte* arg1);

        [DllImport(__DllName, EntryPoint = "perror", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void perror(byte* arg1);

        [DllImport(__DllName, EntryPoint = "printf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int printf(byte* arg1);

        [DllImport(__DllName, EntryPoint = "putc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int putc(int arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "putchar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int putchar(int arg1);

        [DllImport(__DllName, EntryPoint = "puts", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int puts(byte* arg1);

        [DllImport(__DllName, EntryPoint = "remove", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int remove(byte* arg1);

        [DllImport(__DllName, EntryPoint = "rename", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int rename(byte* __old, byte* __new);

        [DllImport(__DllName, EntryPoint = "rewind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void rewind(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "scanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int scanf(byte* arg1);

        [DllImport(__DllName, EntryPoint = "setbuf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void setbuf(__sFILE* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "setvbuf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int setvbuf(__sFILE* arg1, byte* arg2, int arg3, nuint arg4);

        [DllImport(__DllName, EntryPoint = "sprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int sprintf(byte* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "sscanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int sscanf(byte* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "tmpfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* tmpfile();

        [DllImport(__DllName, EntryPoint = "tmpnam", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* tmpnam(byte* arg1);

        [DllImport(__DllName, EntryPoint = "ungetc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ungetc(int arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "vfprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vfprintf(__sFILE* arg1, byte* arg2, byte* arg3);

        [DllImport(__DllName, EntryPoint = "vprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vprintf(byte* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "vsprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vsprintf(byte* arg1, byte* arg2, byte* arg3);

        [DllImport(__DllName, EntryPoint = "ctermid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ctermid(byte* arg1);

        [DllImport(__DllName, EntryPoint = "fdopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* fdopen(int arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "fileno", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fileno(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "pclose", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int pclose(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "popen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* popen(byte* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "flockfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void flockfile(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "ftrylockfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ftrylockfile(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "funlockfile", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void funlockfile(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "getc_unlocked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int getc_unlocked(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "getchar_unlocked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int getchar_unlocked();

        [DllImport(__DllName, EntryPoint = "putc_unlocked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int putc_unlocked(int arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "putchar_unlocked", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int putchar_unlocked(int arg1);

        [DllImport(__DllName, EntryPoint = "getw", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int getw(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "putw", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int putw(int arg1, __sFILE* arg2);

        [DllImport(__DllName, EntryPoint = "tempnam", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* tempnam(byte* __dir, byte* __prefix);

        [DllImport(__DllName, EntryPoint = "fseeko", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fseeko(__sFILE* __stream, long __offset, int __whence);

        [DllImport(__DllName, EntryPoint = "ftello", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ftello(__sFILE* __stream);

        [DllImport(__DllName, EntryPoint = "snprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int snprintf(byte* __str, CULong __size, byte* __format);

        [DllImport(__DllName, EntryPoint = "vfscanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vfscanf(__sFILE* __stream, byte* __format, byte* arg1);

        [DllImport(__DllName, EntryPoint = "vscanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vscanf(byte* __format, byte* arg1);

        [DllImport(__DllName, EntryPoint = "vsnprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vsnprintf(byte* __str, CULong __size, byte* __format, byte* arg1);

        [DllImport(__DllName, EntryPoint = "vsscanf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vsscanf(byte* __str, byte* __format, byte* arg1);

        [DllImport(__DllName, EntryPoint = "dprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int dprintf(int arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "vdprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vdprintf(int arg1, byte* arg2, byte* arg3);

        [DllImport(__DllName, EntryPoint = "getdelim", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nint getdelim(byte** __linep, nuint* __linecapp, int __delimiter, __sFILE* __stream);

        [DllImport(__DllName, EntryPoint = "getline", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nint getline(byte** __linep, nuint* __linecapp, __sFILE* __stream);

        [DllImport(__DllName, EntryPoint = "fmemopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* fmemopen(void* __buf, nuint __size, byte* __mode);

        [DllImport(__DllName, EntryPoint = "open_memstream", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* open_memstream(byte** __bufp, nuint* __sizep);

        [DllImport(__DllName, EntryPoint = "asprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int asprintf(byte** arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "ctermid_r", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ctermid_r(byte* arg1);

        [DllImport(__DllName, EntryPoint = "fgetln", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* fgetln(__sFILE* arg1, nuint* arg2);

        [DllImport(__DllName, EntryPoint = "fmtcheck", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* fmtcheck(byte* arg1, byte* arg2);

        [DllImport(__DllName, EntryPoint = "fpurge", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int fpurge(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "setbuffer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void setbuffer(__sFILE* arg1, byte* arg2, int arg3);

        [DllImport(__DllName, EntryPoint = "setlinebuf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int setlinebuf(__sFILE* arg1);

        [DllImport(__DllName, EntryPoint = "vasprintf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int vasprintf(byte** arg1, byte* arg2, byte* arg3);

        [DllImport(__DllName, EntryPoint = "funopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* funopen(void* arg1, delegate* unmanaged[Cdecl]<void*, byte*, int, int> arg2, delegate* unmanaged[Cdecl]<void*, byte*, int, int> arg3, delegate* unmanaged[Cdecl]<void*, long, int, long> arg4, delegate* unmanaged[Cdecl]<void*, int> arg5);

        [DllImport(__DllName, EntryPoint = "ggml_status_to_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_status_to_string(int status);

        [DllImport(__DllName, EntryPoint = "ggml_fp16_to_fp32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float ggml_fp16_to_fp32(ushort x);

        [DllImport(__DllName, EntryPoint = "ggml_fp32_to_fp16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ushort ggml_fp32_to_fp16(float x);

        [DllImport(__DllName, EntryPoint = "ggml_fp16_to_fp32_row", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_fp16_to_fp32_row(ushort* x, float* y, int n);

        [DllImport(__DllName, EntryPoint = "ggml_fp32_to_fp16_row", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_fp32_to_fp16_row(float* x, ushort* y, int n);

        [DllImport(__DllName, EntryPoint = "ggml_guid_matches", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_guid_matches(void/* byte[] */* guid_a, void/* byte[] */* guid_b);

        [DllImport(__DllName, EntryPoint = "ggml_time_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_time_init();

        [DllImport(__DllName, EntryPoint = "ggml_time_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_time_ms();

        [DllImport(__DllName, EntryPoint = "ggml_time_us", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_time_us();

        [DllImport(__DllName, EntryPoint = "ggml_cycles", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_cycles();

        [DllImport(__DllName, EntryPoint = "ggml_cycles_per_ms", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_cycles_per_ms();

        [DllImport(__DllName, EntryPoint = "ggml_print_backtrace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_print_backtrace();

        [DllImport(__DllName, EntryPoint = "ggml_fopen", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern __sFILE* ggml_fopen(byte* fname, byte* mode);

        [DllImport(__DllName, EntryPoint = "ggml_numa_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_numa_init(uint numa);

        [DllImport(__DllName, EntryPoint = "ggml_is_numa", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_numa();

        [DllImport(__DllName, EntryPoint = "ggml_print_object", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_print_object(ggml_object* obj);

        [DllImport(__DllName, EntryPoint = "ggml_print_objects", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_print_objects(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_nelements", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_nelements(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_nrows", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long ggml_nrows(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_nbytes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_nbytes(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_nbytes_pad", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_nbytes_pad(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_blck_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_blck_size(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_type_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_type_size(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_row_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_row_size(uint type_, long ne);

        [DllImport(__DllName, EntryPoint = "ggml_type_sizef", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern double ggml_type_sizef(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_type_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_type_name(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_op_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_op_name(uint op);

        [DllImport(__DllName, EntryPoint = "ggml_op_symbol", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_op_symbol(uint op);

        [DllImport(__DllName, EntryPoint = "ggml_unary_op_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_unary_op_name(uint op);

        [DllImport(__DllName, EntryPoint = "ggml_op_desc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_op_desc(ggml_tensor* t);

        [DllImport(__DllName, EntryPoint = "ggml_element_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_element_size(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_quantized", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_quantized(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_ftype_to_ggml_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint ggml_ftype_to_ggml_type(int ftype);

        [DllImport(__DllName, EntryPoint = "ggml_is_transposed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_transposed(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_contiguous", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_contiguous(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_permuted", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_permuted(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_empty(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_scalar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_scalar(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_vector", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_vector(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_matrix", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_matrix(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_is_3d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_is_3d(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_n_dims", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_n_dims(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_are_same_shape", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_are_same_shape(ggml_tensor* t0, ggml_tensor* t1);

        [DllImport(__DllName, EntryPoint = "ggml_tensor_overhead", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_tensor_overhead();

        [DllImport(__DllName, EntryPoint = "ggml_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_context* ggml_init(ggml_init_params @params);

        [DllImport(__DllName, EntryPoint = "ggml_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_free(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_used_mem", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_used_mem(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_set_scratch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_set_scratch(ggml_context* ctx, ggml_scratch scratch);

        [DllImport(__DllName, EntryPoint = "ggml_get_no_alloc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_get_no_alloc(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_set_no_alloc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_no_alloc(ggml_context* ctx, [MarshalAs(UnmanagedType.U1)] bool no_alloc);

        [DllImport(__DllName, EntryPoint = "ggml_get_mem_buffer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* ggml_get_mem_buffer(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_get_mem_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_get_mem_size(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_get_max_tensor_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_get_max_tensor_size(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_new_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_tensor(ggml_context* ctx, uint type_, int n_dims, long* ne);

        [DllImport(__DllName, EntryPoint = "ggml_new_tensor_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_tensor_1d(ggml_context* ctx, uint type_, long ne0);

        [DllImport(__DllName, EntryPoint = "ggml_new_tensor_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_tensor_2d(ggml_context* ctx, uint type_, long ne0, long ne1);

        [DllImport(__DllName, EntryPoint = "ggml_new_tensor_3d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_tensor_3d(ggml_context* ctx, uint type_, long ne0, long ne1, long ne2);

        [DllImport(__DllName, EntryPoint = "ggml_new_tensor_4d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_tensor_4d(ggml_context* ctx, uint type_, long ne0, long ne1, long ne2, long ne3);

        [DllImport(__DllName, EntryPoint = "ggml_new_i32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_i32(ggml_context* ctx, int value);

        [DllImport(__DllName, EntryPoint = "ggml_new_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_new_f32(ggml_context* ctx, float value);

        [DllImport(__DllName, EntryPoint = "ggml_dup_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_dup_tensor(ggml_context* ctx, ggml_tensor* src);

        [DllImport(__DllName, EntryPoint = "ggml_view_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_view_tensor(ggml_context* ctx, ggml_tensor* src);

        [DllImport(__DllName, EntryPoint = "ggml_get_first_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_first_tensor(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_get_next_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_next_tensor(ggml_context* ctx, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_get_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_tensor(ggml_context* ctx, byte* name);

        [DllImport(__DllName, EntryPoint = "ggml_set_zero", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_zero(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_set_i32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_i32(ggml_tensor* tensor, int value);

        [DllImport(__DllName, EntryPoint = "ggml_set_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_f32(ggml_tensor* tensor, float value);

        [DllImport(__DllName, EntryPoint = "ggml_unravel_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_unravel_index(ggml_tensor* tensor, long i, long* i0, long* i1, long* i2, long* i3);

        [DllImport(__DllName, EntryPoint = "ggml_get_i32_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_get_i32_1d(ggml_tensor* tensor, int i);

        [DllImport(__DllName, EntryPoint = "ggml_set_i32_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_i32_1d(ggml_tensor* tensor, int i, int value);

        [DllImport(__DllName, EntryPoint = "ggml_get_i32_nd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_get_i32_nd(ggml_tensor* tensor, int i0, int i1, int i2, int i3);

        [DllImport(__DllName, EntryPoint = "ggml_set_i32_nd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_i32_nd(ggml_tensor* tensor, int i0, int i1, int i2, int i3, int value);

        [DllImport(__DllName, EntryPoint = "ggml_get_f32_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float ggml_get_f32_1d(ggml_tensor* tensor, int i);

        [DllImport(__DllName, EntryPoint = "ggml_set_f32_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_f32_1d(ggml_tensor* tensor, int i, float value);

        [DllImport(__DllName, EntryPoint = "ggml_get_f32_nd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float ggml_get_f32_nd(ggml_tensor* tensor, int i0, int i1, int i2, int i3);

        [DllImport(__DllName, EntryPoint = "ggml_set_f32_nd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_f32_nd(ggml_tensor* tensor, int i0, int i1, int i2, int i3, float value);

        [DllImport(__DllName, EntryPoint = "ggml_get_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* ggml_get_data(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_get_data_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* ggml_get_data_f32(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_get_unary_op", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint ggml_get_unary_op(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_get_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_get_name(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_set_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_name(ggml_tensor* tensor, byte* name);

        [DllImport(__DllName, EntryPoint = "ggml_format_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_format_name(ggml_tensor* tensor, byte* fmt);

        [DllImport(__DllName, EntryPoint = "ggml_dup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_dup(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_dup_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_dup_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_add", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_add_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_add_cast", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add_cast(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_add1", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add1(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_add1_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add1_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_acc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_acc(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint nb2, nuint nb3, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_acc_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_acc_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint nb2, nuint nb3, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_sub", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sub(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_sub_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sub_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_mul", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_mul(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_mul_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_mul_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_div", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_div(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_div_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_div_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_sqr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sqr(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sqr_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sqr_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sqrt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sqrt(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sqrt_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sqrt_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_log", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_log(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_log_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_log_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sum", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sum(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sum_rows", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sum_rows(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_mean", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_mean(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_argmax", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_argmax(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_repeat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_repeat(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_repeat_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_repeat_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_concat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_concat(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_abs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_abs(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_abs_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_abs_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sgn", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sgn(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_sgn_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_sgn_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_neg", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_neg(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_neg_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_neg_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_step", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_step(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_step_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_step_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_tanh", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_tanh(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_tanh_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_tanh_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_elu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_elu(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_elu_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_elu_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_relu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_relu(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_leaky_relu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_leaky_relu(ggml_context* ctx, ggml_tensor* a, float negative_slope, [MarshalAs(UnmanagedType.U1)] bool inplace);

        [DllImport(__DllName, EntryPoint = "ggml_relu_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_relu_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_gelu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_gelu(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_gelu_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_gelu_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_gelu_quick", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_gelu_quick(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_gelu_quick_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_gelu_quick_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_silu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_silu(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_silu_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_silu_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_silu_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_silu_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_hardswish", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_hardswish(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_hardsigmoid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_hardsigmoid(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_norm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_norm(ggml_context* ctx, ggml_tensor* a, float eps);

        [DllImport(__DllName, EntryPoint = "ggml_norm_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_norm_inplace(ggml_context* ctx, ggml_tensor* a, float eps);

        [DllImport(__DllName, EntryPoint = "ggml_rms_norm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rms_norm(ggml_context* ctx, ggml_tensor* a, float eps);

        [DllImport(__DllName, EntryPoint = "ggml_rms_norm_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rms_norm_inplace(ggml_context* ctx, ggml_tensor* a, float eps);

        [DllImport(__DllName, EntryPoint = "ggml_group_norm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_group_norm(ggml_context* ctx, ggml_tensor* a, int n_groups);

        [DllImport(__DllName, EntryPoint = "ggml_group_norm_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_group_norm_inplace(ggml_context* ctx, ggml_tensor* a, int n_groups);

        [DllImport(__DllName, EntryPoint = "ggml_rms_norm_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rms_norm_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, float eps);

        [DllImport(__DllName, EntryPoint = "ggml_mul_mat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_mul_mat(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_mul_mat_set_prec", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_mul_mat_set_prec(ggml_tensor* a, uint prec);

        [DllImport(__DllName, EntryPoint = "ggml_mul_mat_id", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_mul_mat_id(ggml_context* ctx, ggml_tensor** as_, int n_as, ggml_tensor* ids, int id, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_out_prod", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_out_prod(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_scale", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_scale(ggml_context* ctx, ggml_tensor* a, float s);

        [DllImport(__DllName, EntryPoint = "ggml_scale_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_scale_inplace(ggml_context* ctx, ggml_tensor* a, float s);

        [DllImport(__DllName, EntryPoint = "ggml_set", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint nb2, nuint nb3, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_set_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint nb2, nuint nb3, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_set_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_1d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_set_1d_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_1d_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_set_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_2d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_set_2d_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_set_2d_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, nuint nb1, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_cpy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cpy(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_cast", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cast(ggml_context* ctx, ggml_tensor* a, uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_cont", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cont(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_cont_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cont_1d(ggml_context* ctx, ggml_tensor* a, long ne0);

        [DllImport(__DllName, EntryPoint = "ggml_cont_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cont_2d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1);

        [DllImport(__DllName, EntryPoint = "ggml_cont_3d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cont_3d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2);

        [DllImport(__DllName, EntryPoint = "ggml_cont_4d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cont_4d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2, long ne3);

        [DllImport(__DllName, EntryPoint = "ggml_reshape", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_reshape(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_reshape_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_reshape_1d(ggml_context* ctx, ggml_tensor* a, long ne0);

        [DllImport(__DllName, EntryPoint = "ggml_reshape_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_reshape_2d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1);

        [DllImport(__DllName, EntryPoint = "ggml_reshape_3d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_reshape_3d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2);

        [DllImport(__DllName, EntryPoint = "ggml_reshape_4d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_reshape_4d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2, long ne3);

        [DllImport(__DllName, EntryPoint = "ggml_view_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_view_1d(ggml_context* ctx, ggml_tensor* a, long ne0, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_view_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_view_2d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, nuint nb1, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_view_3d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_view_3d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2, nuint nb1, nuint nb2, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_view_4d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_view_4d(ggml_context* ctx, ggml_tensor* a, long ne0, long ne1, long ne2, long ne3, nuint nb1, nuint nb2, nuint nb3, nuint offset);

        [DllImport(__DllName, EntryPoint = "ggml_permute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_permute(ggml_context* ctx, ggml_tensor* a, int axis0, int axis1, int axis2, int axis3);

        [DllImport(__DllName, EntryPoint = "ggml_transpose", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_transpose(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_get_rows", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_rows(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_get_rows_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_rows_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c);

        [DllImport(__DllName, EntryPoint = "ggml_diag", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_diag(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_diag_mask_inf", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_diag_mask_inf(ggml_context* ctx, ggml_tensor* a, int n_past);

        [DllImport(__DllName, EntryPoint = "ggml_diag_mask_inf_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_diag_mask_inf_inplace(ggml_context* ctx, ggml_tensor* a, int n_past);

        [DllImport(__DllName, EntryPoint = "ggml_diag_mask_zero", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_diag_mask_zero(ggml_context* ctx, ggml_tensor* a, int n_past);

        [DllImport(__DllName, EntryPoint = "ggml_diag_mask_zero_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_diag_mask_zero_inplace(ggml_context* ctx, ggml_tensor* a, int n_past);

        [DllImport(__DllName, EntryPoint = "ggml_soft_max", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_soft_max(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_soft_max_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_soft_max_inplace(ggml_context* ctx, ggml_tensor* a);

        [DllImport(__DllName, EntryPoint = "ggml_soft_max_ext", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_soft_max_ext(ggml_context* ctx, ggml_tensor* a, ggml_tensor* mask, ggml_tensor* pos, float scale, float max_bias);

        [DllImport(__DllName, EntryPoint = "ggml_soft_max_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_soft_max_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_soft_max_back_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_soft_max_back_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_rope", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, int mode, int n_ctx);

        [DllImport(__DllName, EntryPoint = "ggml_rope_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, int mode, int n_ctx);

        [DllImport(__DllName, EntryPoint = "ggml_rope_custom", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope_custom(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, int mode, int n_ctx, int n_orig_ctx, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow);

        [DllImport(__DllName, EntryPoint = "ggml_rope_custom_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope_custom_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, int mode, int n_ctx, int n_orig_ctx, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow);

        [DllImport(__DllName, EntryPoint = "ggml_rope_yarn_corr_dims", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_rope_yarn_corr_dims(int n_dims, int n_orig_ctx, float freq_base, float beta_fast, float beta_slow, float* dims);

        [DllImport(__DllName, EntryPoint = "ggml_rope_xpos_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope_xpos_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, float @base, [MarshalAs(UnmanagedType.U1)] bool down);

        [DllImport(__DllName, EntryPoint = "ggml_rope_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_rope_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int n_dims, int mode, int n_ctx, int n_orig_ctx, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow, float xpos_base, [MarshalAs(UnmanagedType.U1)] bool xpos_down);

        [DllImport(__DllName, EntryPoint = "ggml_alibi", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_alibi(ggml_context* ctx, ggml_tensor* a, int n_past, int n_head, float bias_max);

        [DllImport(__DllName, EntryPoint = "ggml_clamp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_clamp(ggml_context* ctx, ggml_tensor* a, float min, float max);

        [DllImport(__DllName, EntryPoint = "ggml_im2col", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_im2col(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s0, int s1, int p0, int p1, int d0, int d1, [MarshalAs(UnmanagedType.U1)] bool is_2D, uint dst_type);

        [DllImport(__DllName, EntryPoint = "ggml_conv_depthwise_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_depthwise_2d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s0, int s1, int p0, int p1, int d0, int d1);

        [DllImport(__DllName, EntryPoint = "ggml_conv_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_1d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s0, int p0, int d0);

        [DllImport(__DllName, EntryPoint = "ggml_conv_1d_ph", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_1d_ph(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s, int d);

        [DllImport(__DllName, EntryPoint = "ggml_conv_transpose_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_transpose_1d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s0, int p0, int d0);

        [DllImport(__DllName, EntryPoint = "ggml_conv_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_2d(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int s0, int s1, int p0, int p1, int d0, int d1);

        [DllImport(__DllName, EntryPoint = "ggml_conv_2d_sk_p0", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_2d_sk_p0(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_conv_2d_s1_ph", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_2d_s1_ph(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_conv_transpose_2d_p0", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_conv_transpose_2d_p0(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, int stride);

        [DllImport(__DllName, EntryPoint = "ggml_pool_1d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_pool_1d(ggml_context* ctx, ggml_tensor* a, uint op, int k0, int s0, int p0);

        [DllImport(__DllName, EntryPoint = "ggml_pool_2d", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_pool_2d(ggml_context* ctx, ggml_tensor* a, uint op, int k0, int k1, int s0, int s1, float p0, float p1);

        [DllImport(__DllName, EntryPoint = "ggml_upscale", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_upscale(ggml_context* ctx, ggml_tensor* a, int scale_factor);

        [DllImport(__DllName, EntryPoint = "ggml_pad", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_pad(ggml_context* ctx, ggml_tensor* a, int p0, int p1, int p2, int p3);

        [DllImport(__DllName, EntryPoint = "ggml_timestep_embedding", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_timestep_embedding(ggml_context* ctx, ggml_tensor* timesteps, int dim, int max_period);

        [DllImport(__DllName, EntryPoint = "ggml_argsort", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_argsort(ggml_context* ctx, ggml_tensor* a, uint order);

        [DllImport(__DllName, EntryPoint = "ggml_arange", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_arange(ggml_context* ctx, float start, float stop, float step);

        [DllImport(__DllName, EntryPoint = "ggml_top_k", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_top_k(ggml_context* ctx, ggml_tensor* a, int k);

        [DllImport(__DllName, EntryPoint = "ggml_flash_attn", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_flash_attn(ggml_context* ctx, ggml_tensor* q, ggml_tensor* k, ggml_tensor* v, [MarshalAs(UnmanagedType.U1)] bool masked);

        [DllImport(__DllName, EntryPoint = "ggml_flash_attn_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_flash_attn_back(ggml_context* ctx, ggml_tensor* q, ggml_tensor* k, ggml_tensor* v, ggml_tensor* d, [MarshalAs(UnmanagedType.U1)] bool masked);

        [DllImport(__DllName, EntryPoint = "ggml_flash_ff", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_flash_ff(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b0, ggml_tensor* b1, ggml_tensor* c0, ggml_tensor* c1);

        [DllImport(__DllName, EntryPoint = "ggml_ssm_conv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_ssm_conv(ggml_context* ctx, ggml_tensor* s, ggml_tensor* x, ggml_tensor* c, ggml_tensor* sq);

        [DllImport(__DllName, EntryPoint = "ggml_ssm_scan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_ssm_scan(ggml_context* ctx, ggml_tensor* s, ggml_tensor* x, ggml_tensor* dt, ggml_tensor* A, ggml_tensor* B, ggml_tensor* C, ggml_tensor* sq);

        [DllImport(__DllName, EntryPoint = "ggml_win_part", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_win_part(ggml_context* ctx, ggml_tensor* a, int w);

        [DllImport(__DllName, EntryPoint = "ggml_win_unpart", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_win_unpart(ggml_context* ctx, ggml_tensor* a, int w0, int h0, int w);

        [DllImport(__DllName, EntryPoint = "ggml_unary", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_unary(ggml_context* ctx, ggml_tensor* a, uint op);

        [DllImport(__DllName, EntryPoint = "ggml_unary_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_unary_inplace(ggml_context* ctx, ggml_tensor* a, uint op);

        [DllImport(__DllName, EntryPoint = "ggml_get_rel_pos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_get_rel_pos(ggml_context* ctx, ggml_tensor* a, int qh, int kh);

        [DllImport(__DllName, EntryPoint = "ggml_add_rel_pos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add_rel_pos(ggml_context* ctx, ggml_tensor* a, ggml_tensor* pw, ggml_tensor* ph);

        [DllImport(__DllName, EntryPoint = "ggml_add_rel_pos_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_add_rel_pos_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* pw, ggml_tensor* ph);

        [DllImport(__DllName, EntryPoint = "ggml_map_unary_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_unary_f32(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<int, float*, float*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_unary_inplace_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_unary_inplace_f32(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<int, float*, float*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_binary_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_binary_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<int, float*, float*, float*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_binary_inplace_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_binary_inplace_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<int, float*, float*, float*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom1_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom1_f32(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom1_inplace_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom1_inplace_f32(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom2_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom2_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom2_inplace_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom2_inplace_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom3_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom3_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom3_inplace_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom3_inplace_f32(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, ggml_tensor*, void> fun);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom1", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom1(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom1_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom1_inplace(ggml_context* ctx, ggml_tensor* a, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom2", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom2(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom2_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom2_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom3", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom3(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_map_custom3_inplace", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_map_custom3_inplace(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c, delegate* unmanaged[Cdecl]<ggml_tensor*, ggml_tensor*, ggml_tensor*, ggml_tensor*, int, int, void*, void> fun, int n_tasks, void* userdata);

        [DllImport(__DllName, EntryPoint = "ggml_cross_entropy_loss", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cross_entropy_loss(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b);

        [DllImport(__DllName, EntryPoint = "ggml_cross_entropy_loss_back", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_cross_entropy_loss_back(ggml_context* ctx, ggml_tensor* a, ggml_tensor* b, ggml_tensor* c);

        [DllImport(__DllName, EntryPoint = "ggml_set_param", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_param(ggml_context* ctx, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_build_forward_expand", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_build_forward_expand(ggml_cgraph* cgraph, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_build_backward_expand", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_build_backward_expand(ggml_context* ctx, ggml_cgraph* gf, ggml_cgraph* gb, [MarshalAs(UnmanagedType.U1)] bool keep);

        [DllImport(__DllName, EntryPoint = "ggml_new_graph", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cgraph* ggml_new_graph(ggml_context* ctx);

        [DllImport(__DllName, EntryPoint = "ggml_new_graph_custom", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cgraph* ggml_new_graph_custom(ggml_context* ctx, nuint size, [MarshalAs(UnmanagedType.U1)] bool grads);

        [DllImport(__DllName, EntryPoint = "ggml_graph_dup", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cgraph* ggml_graph_dup(ggml_context* ctx, ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_graph_view", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cgraph ggml_graph_view(ggml_cgraph* cgraph, int i0, int i1);

        [DllImport(__DllName, EntryPoint = "ggml_graph_cpy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_cpy(ggml_cgraph* src, ggml_cgraph* dst);

        [DllImport(__DllName, EntryPoint = "ggml_graph_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_reset(ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_graph_clear", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_clear(ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_graph_overhead", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_graph_overhead();

        [DllImport(__DllName, EntryPoint = "ggml_graph_overhead_custom", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_graph_overhead_custom(nuint size, [MarshalAs(UnmanagedType.U1)] bool grads);

        [DllImport(__DllName, EntryPoint = "ggml_graph_plan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cplan ggml_graph_plan(ggml_cgraph* cgraph, int n_threads);

        [DllImport(__DllName, EntryPoint = "ggml_graph_compute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_graph_compute(ggml_cgraph* cgraph, ggml_cplan* cplan);

        [DllImport(__DllName, EntryPoint = "ggml_graph_compute_with_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_graph_compute_with_ctx(ggml_context* ctx, ggml_cgraph* cgraph, int n_threads);

        [DllImport(__DllName, EntryPoint = "ggml_graph_get_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* ggml_graph_get_tensor(ggml_cgraph* cgraph, byte* name);

        [DllImport(__DllName, EntryPoint = "ggml_graph_export", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_export(ggml_cgraph* cgraph, byte* fname);

        [DllImport(__DllName, EntryPoint = "ggml_graph_import", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_cgraph* ggml_graph_import(byte* fname, ggml_context** ctx_data, ggml_context** ctx_eval);

        [DllImport(__DllName, EntryPoint = "ggml_graph_print", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_print(ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_graph_dump_dot", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_graph_dump_dot(ggml_cgraph* gb, ggml_cgraph* gf, byte* filename);

        [DllImport(__DllName, EntryPoint = "ggml_build_backward_gradient_checkpointing", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_build_backward_gradient_checkpointing(ggml_context* ctx, ggml_cgraph* gf, ggml_cgraph* gb, ggml_cgraph* gb_tmp, ggml_tensor** checkpoints, int n_checkpoints);

        [DllImport(__DllName, EntryPoint = "ggml_opt_default_params", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_opt_params ggml_opt_default_params(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_opt", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_opt(ggml_context* ctx, ggml_opt_params @params, ggml_tensor* f);

        [DllImport(__DllName, EntryPoint = "ggml_opt_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_opt_init(ggml_context* ctx, ggml_opt_context* opt, ggml_opt_params @params, long nx);

        [DllImport(__DllName, EntryPoint = "ggml_opt_resume", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_opt_resume(ggml_context* ctx, ggml_opt_context* opt, ggml_tensor* f);

        [DllImport(__DllName, EntryPoint = "ggml_opt_resume_g", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_opt_resume_g(ggml_context* ctx, ggml_opt_context* opt, ggml_tensor* f, ggml_cgraph* gf, ggml_cgraph* gb, delegate* unmanaged[Cdecl]<void*, int, float*, bool*, void> callback, void* callback_data);

        [DllImport(__DllName, EntryPoint = "ggml_set_input", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_input(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_set_output", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_set_output(ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_quantize_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_quantize_init(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_quantize_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_quantize_free();

        [DllImport(__DllName, EntryPoint = "ggml_quantize_requires_imatrix", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_quantize_requires_imatrix(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_quantize_chunk", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_quantize_chunk(uint type_, float* src, void* dst, int start, int nrows, int n_per_row, float* imatrix);

        [DllImport(__DllName, EntryPoint = "gguf_init_empty", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern gguf_context* gguf_init_empty();

        [DllImport(__DllName, EntryPoint = "gguf_init_from_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern gguf_context* gguf_init_from_file(byte* fname, gguf_init_params @params);

        [DllImport(__DllName, EntryPoint = "gguf_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_free(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_type_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gguf_type_name(uint type_);

        [DllImport(__DllName, EntryPoint = "gguf_get_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_get_version(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_get_alignment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint gguf_get_alignment(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_get_data_offset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint gguf_get_data_offset(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_get_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* gguf_get_data(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_get_n_kv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_get_n_kv(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_find_key", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_find_key(gguf_context* ctx, byte* key);

        [DllImport(__DllName, EntryPoint = "gguf_get_key", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gguf_get_key(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_kv_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint gguf_get_kv_type(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_arr_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint gguf_get_arr_type(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_u8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte gguf_get_val_u8(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_i8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern sbyte gguf_get_val_i8(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_u16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ushort gguf_get_val_u16(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_i16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern short gguf_get_val_i16(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_u32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint gguf_get_val_u32(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_i32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_get_val_i32(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float gguf_get_val_f32(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_u64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong gguf_get_val_u64(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_i64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long gguf_get_val_i64(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_f64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern double gguf_get_val_f64(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool gguf_get_val_bool(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gguf_get_val_str(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_val_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* gguf_get_val_data(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_arr_n", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_get_arr_n(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_arr_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* gguf_get_arr_data(gguf_context* ctx, int key_id);

        [DllImport(__DllName, EntryPoint = "gguf_get_arr_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gguf_get_arr_str(gguf_context* ctx, int key_id, int i);

        [DllImport(__DllName, EntryPoint = "gguf_get_n_tensors", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_get_n_tensors(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_find_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int gguf_find_tensor(gguf_context* ctx, byte* name);

        [DllImport(__DllName, EntryPoint = "gguf_get_tensor_offset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint gguf_get_tensor_offset(gguf_context* ctx, int i);

        [DllImport(__DllName, EntryPoint = "gguf_get_tensor_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* gguf_get_tensor_name(gguf_context* ctx, int i);

        [DllImport(__DllName, EntryPoint = "gguf_get_tensor_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint gguf_get_tensor_type(gguf_context* ctx, int i);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_u8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_u8(gguf_context* ctx, byte* key, byte val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_i8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_i8(gguf_context* ctx, byte* key, sbyte val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_u16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_u16(gguf_context* ctx, byte* key, ushort val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_i16", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_i16(gguf_context* ctx, byte* key, short val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_u32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_u32(gguf_context* ctx, byte* key, uint val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_i32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_i32(gguf_context* ctx, byte* key, int val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_f32", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_f32(gguf_context* ctx, byte* key, float val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_u64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_u64(gguf_context* ctx, byte* key, ulong val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_i64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_i64(gguf_context* ctx, byte* key, long val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_f64", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_f64(gguf_context* ctx, byte* key, double val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_bool", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_bool(gguf_context* ctx, byte* key, [MarshalAs(UnmanagedType.U1)] bool val);

        [DllImport(__DllName, EntryPoint = "gguf_set_val_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_val_str(gguf_context* ctx, byte* key, byte* val);

        [DllImport(__DllName, EntryPoint = "gguf_set_arr_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_arr_data(gguf_context* ctx, byte* key, uint type_, void* data, int n);

        [DllImport(__DllName, EntryPoint = "gguf_set_arr_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_arr_str(gguf_context* ctx, byte* key, byte** data, int n);

        [DllImport(__DllName, EntryPoint = "gguf_set_kv", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_kv(gguf_context* ctx, gguf_context* src);

        [DllImport(__DllName, EntryPoint = "gguf_add_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_add_tensor(gguf_context* ctx, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "gguf_set_tensor_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_tensor_type(gguf_context* ctx, byte* name, uint type_);

        [DllImport(__DllName, EntryPoint = "gguf_set_tensor_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_set_tensor_data(gguf_context* ctx, byte* name, void* data, nuint size);

        [DllImport(__DllName, EntryPoint = "gguf_write_to_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_write_to_file(gguf_context* ctx, byte* fname, [MarshalAs(UnmanagedType.U1)] bool only_meta);

        [DllImport(__DllName, EntryPoint = "gguf_get_meta_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint gguf_get_meta_size(gguf_context* ctx);

        [DllImport(__DllName, EntryPoint = "gguf_get_meta_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void gguf_get_meta_data(gguf_context* ctx, void* data);

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx_vnni", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx_vnni();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx2", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx2();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx512", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx512();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx512_vbmi", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx512_vbmi();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_avx512_vnni", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_avx512_vnni();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_fma", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_fma();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_neon", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_neon();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_arm_fma", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_arm_fma();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_metal", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_metal();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_f16c", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_f16c();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_fp16_va", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_fp16_va();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_wasm_simd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_wasm_simd();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_blas", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_blas();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_cuda", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_cuda();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_clblast", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_clblast();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_vulkan", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_vulkan();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_kompute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_kompute();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_gpublas", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_gpublas();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_sse3", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_sse3();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_ssse3", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_ssse3();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_sycl", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_sycl();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_vsx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_vsx();

        [DllImport(__DllName, EntryPoint = "ggml_cpu_has_matmul_int8", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_cpu_has_matmul_int8();

        [DllImport(__DllName, EntryPoint = "ggml_internal_get_type_traits", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_type_traits_t ggml_internal_get_type_traits(uint type_);

        [DllImport(__DllName, EntryPoint = "ggml_tallocr_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tallocr ggml_tallocr_new(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_tallocr_alloc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_tallocr_alloc(ggml_tallocr* talloc, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_gallocr* ggml_gallocr_new(ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_new_n", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_gallocr* ggml_gallocr_new_n(ggml_backend_buffer_type** bufts, int n_bufs);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_gallocr_free(ggml_gallocr* galloc);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_reserve", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_gallocr_reserve(ggml_gallocr* galloc, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_reserve_n", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_gallocr_reserve_n(ggml_gallocr* galloc, ggml_cgraph* graph, int* node_buffer_ids, int* leaf_buffer_ids);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_alloc_graph", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_gallocr_alloc_graph(ggml_gallocr* galloc, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_gallocr_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_gallocr_get_buffer_size(ggml_gallocr* galloc, int buffer_id);

        [DllImport(__DllName, EntryPoint = "ggml_backend_alloc_ctx_tensors_from_buft", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_alloc_ctx_tensors_from_buft(ggml_context* ctx, ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_backend_alloc_ctx_tensors", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_alloc_ctx_tensors(ggml_context* ctx, ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_backend_buft_name(ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_alloc_buffer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type* buft, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_get_alignment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buft_get_alignment(ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_get_max_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buft_get_max_size(ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_get_alloc_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type* buft, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_supports_backend", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_buft_supports_backend(ggml_backend_buffer_type* buft, ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buft_is_host", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type* buft);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_backend_buffer_name(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_buffer_free(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_base", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* ggml_backend_buffer_get_base(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buffer_get_size(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_init_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_buffer_init_tensor(ggml_backend_buffer* buffer, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_alignment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buffer_get_alignment(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_max_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buffer_get_max_size(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_alloc_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_buffer_get_alloc_size(ggml_backend_buffer* buffer, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_clear", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_buffer_clear(ggml_backend_buffer* buffer, byte value);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_is_host", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_buffer_is_host(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_set_usage", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_buffer_set_usage(ggml_backend_buffer* buffer, uint usage);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_get_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer_type* ggml_backend_buffer_get_type(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_buffer_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_buffer_reset(ggml_backend_buffer* buffer);

        [DllImport(__DllName, EntryPoint = "ggml_backend_guid", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void/* byte[] */* ggml_backend_guid(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_backend_name(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_free(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_get_default_buffer_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer_type* ggml_backend_get_default_buffer_type(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_alloc_buffer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_alloc_buffer(ggml_backend* backend, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_get_alignment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_get_alignment(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_get_max_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_get_max_size(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_set_async", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_set_async(ggml_backend* backend, ggml_tensor* tensor, void* data, nuint offset, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_get_async", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_get_async(ggml_backend* backend, ggml_tensor* tensor, void* data, nuint offset, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_set", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_set(ggml_tensor* tensor, void* data, nuint offset, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_get", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_get(ggml_tensor* tensor, void* data, nuint offset, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_synchronize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_synchronize(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_plan_create", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void* ggml_backend_graph_plan_create(ggml_backend* backend, ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_plan_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_graph_plan_free(ggml_backend* backend, void* plan);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_plan_compute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_graph_plan_compute(ggml_backend* backend, void* plan);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_compute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_graph_compute(ggml_backend* backend, ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_compute_async", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_graph_compute_async(ggml_backend* backend, ggml_cgraph* cgraph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_supports_op", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_supports_op(ggml_backend* backend, ggml_tensor* op);

        [DllImport(__DllName, EntryPoint = "ggml_backend_offload_op", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_offload_op(ggml_backend* backend, ggml_tensor* op);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_copy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_copy(ggml_tensor* src, ggml_tensor* dst);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_copy_async", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_copy_async(ggml_backend* backend_src, ggml_backend* backend_dst, ggml_tensor* src, ggml_tensor* dst);

        [DllImport(__DllName, EntryPoint = "ggml_backend_event_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_event* ggml_backend_event_new(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_event_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_event_free(ggml_backend_event* @event);

        [DllImport(__DllName, EntryPoint = "ggml_backend_event_record", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_event_record(ggml_backend_event* @event);

        [DllImport(__DllName, EntryPoint = "ggml_backend_event_synchronize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_event_synchronize(ggml_backend_event* @event);

        [DllImport(__DllName, EntryPoint = "ggml_backend_event_wait", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_event_wait(ggml_backend* backend, ggml_backend_event* @event);

        [DllImport(__DllName, EntryPoint = "ggml_backend_cpu_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend* ggml_backend_cpu_init();

        [DllImport(__DllName, EntryPoint = "ggml_backend_is_cpu", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_is_cpu(ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_cpu_set_n_threads", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_cpu_set_n_threads(ggml_backend* backend_cpu, int n_threads);

        [DllImport(__DllName, EntryPoint = "ggml_backend_cpu_set_abort_callback", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_cpu_set_abort_callback(ggml_backend* backend_cpu, delegate* unmanaged[Cdecl]<void*, bool> abort_callback, void* abort_callback_data);

        [DllImport(__DllName, EntryPoint = "ggml_backend_cpu_buffer_from_ptr", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_cpu_buffer_from_ptr(void* ptr, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_cpu_buffer_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer_type* ggml_backend_cpu_buffer_type();

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_get_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_reg_get_count();

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_find_by_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_reg_find_by_name(byte* name);

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_init_backend_from_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend* ggml_backend_reg_init_backend_from_str(byte* backend_str);

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_get_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* ggml_backend_reg_get_name(nuint i);

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_init_backend", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend* ggml_backend_reg_init_backend(nuint i, byte* @params);

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_get_default_buffer_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer_type* ggml_backend_reg_get_default_buffer_type(nuint i);

        [DllImport(__DllName, EntryPoint = "ggml_backend_reg_alloc_buffer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_buffer* ggml_backend_reg_alloc_buffer(nuint i, nuint size);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_sched* ggml_backend_sched_new(ggml_backend** backends, ggml_backend_buffer_type** bufts, int n_backends, nuint graph_size, [MarshalAs(UnmanagedType.U1)] bool parallel);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_sched_free(ggml_backend_sched* sched);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_reserve", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_sched_reserve(ggml_backend_sched* sched, ggml_cgraph* measure_graph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_get_n_splits", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_sched_get_n_splits(ggml_backend_sched* sched);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_get_n_copies", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_sched_get_n_copies(ggml_backend_sched* sched);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_get_buffer_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint ggml_backend_sched_get_buffer_size(ggml_backend_sched* sched, ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_set_tensor_backend", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched* sched, ggml_tensor* node, ggml_backend* backend);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_get_tensor_backend", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend* ggml_backend_sched_get_tensor_backend(ggml_backend_sched* sched, ggml_tensor* node);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_alloc_graph", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched* sched, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_graph_compute", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_sched_graph_compute(ggml_backend_sched* sched, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_graph_compute_async", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int ggml_backend_sched_graph_compute_async(ggml_backend_sched* sched, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_synchronize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_sched_synchronize(ggml_backend_sched* sched);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_reset", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_sched_reset(ggml_backend_sched* sched);

        [DllImport(__DllName, EntryPoint = "ggml_backend_sched_set_eval_callback", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched* sched, delegate* unmanaged[Cdecl]<ggml_tensor*, bool, void*, bool> callback, void* user_data);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_copy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend* backend, ggml_cgraph* graph);

        [DllImport(__DllName, EntryPoint = "ggml_backend_graph_copy_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_graph_copy_free(ggml_backend_graph_copy copy);

        [DllImport(__DllName, EntryPoint = "ggml_backend_compare_graph_backend", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool ggml_backend_compare_graph_backend(ggml_backend* backend1, ggml_backend* backend2, ggml_cgraph* graph, delegate* unmanaged[Cdecl]<int, ggml_tensor*, ggml_tensor*, void*, bool> callback, void* user_data);

        [DllImport(__DllName, EntryPoint = "ggml_backend_tensor_alloc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_tensor_alloc(ggml_backend_buffer* buffer, ggml_tensor* tensor, void* addr);

        [DllImport(__DllName, EntryPoint = "ggml_backend_view_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void ggml_backend_view_init(ggml_backend_buffer* buffer, ggml_tensor* tensor);

        [DllImport(__DllName, EntryPoint = "llama_model_default_params", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_model_params llama_model_default_params();

        [DllImport(__DllName, EntryPoint = "llama_context_default_params", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_context_params llama_context_default_params();

        [DllImport(__DllName, EntryPoint = "llama_model_quantize_default_params", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_model_quantize_params llama_model_quantize_default_params();

        [DllImport(__DllName, EntryPoint = "llama_backend_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_backend_init();

        [DllImport(__DllName, EntryPoint = "llama_numa_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_numa_init(uint numa);

        [DllImport(__DllName, EntryPoint = "llama_backend_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_backend_free();

        [DllImport(__DllName, EntryPoint = "llama_load_model_from_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_model* llama_load_model_from_file(byte* path_model, llama_model_params @params);

        [DllImport(__DllName, EntryPoint = "llama_free_model", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_free_model(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_new_context_with_model", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_context* llama_new_context_with_model(llama_model* model, llama_context_params @params);

        [DllImport(__DllName, EntryPoint = "llama_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_free(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_time_us", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern long llama_time_us();

        [DllImport(__DllName, EntryPoint = "llama_max_devices", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint llama_max_devices();

        [DllImport(__DllName, EntryPoint = "llama_supports_mmap", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_supports_mmap();

        [DllImport(__DllName, EntryPoint = "llama_supports_mlock", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_supports_mlock();

        [DllImport(__DllName, EntryPoint = "llama_supports_gpu_offload", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_supports_gpu_offload();

        [DllImport(__DllName, EntryPoint = "llama_get_model", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_model* llama_get_model(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_n_ctx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_n_ctx(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_n_batch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_n_batch(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_n_ubatch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_n_ubatch(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_n_seq_max", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_n_seq_max(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_vocab_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_vocab_type(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_rope_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_rope_type(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_n_vocab", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_n_vocab(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_n_ctx_train", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_n_ctx_train(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_n_embd", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_n_embd(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_n_layer", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_n_layer(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_rope_freq_scale_train", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float llama_rope_freq_scale_train(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_model_meta_val_str", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_meta_val_str(llama_model* model, byte* key, byte* buf, nuint buf_size);

        [DllImport(__DllName, EntryPoint = "llama_model_meta_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_meta_count(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_model_meta_key_by_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_meta_key_by_index(llama_model* model, int i, byte* buf, nuint buf_size);

        [DllImport(__DllName, EntryPoint = "llama_model_meta_val_str_by_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_meta_val_str_by_index(llama_model* model, int i, byte* buf, nuint buf_size);

        [DllImport(__DllName, EntryPoint = "llama_model_desc", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_desc(llama_model* model, byte* buf, nuint buf_size);

        [DllImport(__DllName, EntryPoint = "llama_model_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong llama_model_size(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_model_n_params", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong llama_model_n_params(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_get_model_tensor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ggml_tensor* llama_get_model_tensor(llama_model* model, byte* name);

        [DllImport(__DllName, EntryPoint = "llama_model_quantize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_model_quantize(byte* fname_inp, byte* fname_out, llama_model_quantize_params* @params);

        [DllImport(__DllName, EntryPoint = "llama_model_apply_lora_from_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_model_apply_lora_from_file(llama_model* model, byte* path_lora, float scale, byte* path_base_model, int n_threads);

        [DllImport(__DllName, EntryPoint = "llama_control_vector_apply", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_control_vector_apply(llama_context* lctx, float* data, nuint len, int n_embd, int il_start, int il_end);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_view_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_kv_cache_view llama_kv_cache_view_init(llama_context* ctx, int n_seq_max);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_view_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_view_free(llama_kv_cache_view* view);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_view_update", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_view_update(llama_context* ctx, llama_kv_cache_view* view);

        [DllImport(__DllName, EntryPoint = "llama_get_kv_cache_token_count", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_get_kv_cache_token_count(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_get_kv_cache_used_cells", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_get_kv_cache_used_cells(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_clear", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_clear(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_rm", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_kv_cache_seq_rm(llama_context* ctx, int seq_id, int p0, int p1);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_cp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_seq_cp(llama_context* ctx, int seq_id_src, int seq_id_dst, int p0, int p1);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_keep", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_seq_keep(llama_context* ctx, int seq_id);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_add", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_seq_add(llama_context* ctx, int seq_id, int p0, int p1, int delta);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_div", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_seq_div(llama_context* ctx, int seq_id, int p0, int p1, int d);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_seq_pos_max", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_kv_cache_seq_pos_max(llama_context* ctx, int seq_id);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_defrag", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_defrag(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_kv_cache_update", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_kv_cache_update(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_get_state_size", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint llama_get_state_size(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_copy_state_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint llama_copy_state_data(llama_context* ctx, byte* dst);

        [DllImport(__DllName, EntryPoint = "llama_set_state_data", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern nuint llama_set_state_data(llama_context* ctx, byte* src);

        [DllImport(__DllName, EntryPoint = "llama_load_session_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_load_session_file(llama_context* ctx, byte* path_session, int* tokens_out, nuint n_token_capacity, nuint* n_token_count_out);

        [DllImport(__DllName, EntryPoint = "llama_save_session_file", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        [return: MarshalAs(UnmanagedType.U1)]
        public static extern bool llama_save_session_file(llama_context* ctx, byte* path_session, int* tokens, nuint n_token_count);

        [DllImport(__DllName, EntryPoint = "llama_batch_get_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_batch llama_batch_get_one(int* tokens, int n_tokens, int pos_0, int seq_id);

        [DllImport(__DllName, EntryPoint = "llama_batch_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_batch llama_batch_init(int n_tokens, int embd, int n_seq_max);

        [DllImport(__DllName, EntryPoint = "llama_batch_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_batch_free(llama_batch batch);

        [DllImport(__DllName, EntryPoint = "llama_decode", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_decode(llama_context* ctx, llama_batch batch);

        [DllImport(__DllName, EntryPoint = "llama_set_n_threads", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_set_n_threads(llama_context* ctx, uint n_threads, uint n_threads_batch);

        [DllImport(__DllName, EntryPoint = "llama_set_causal_attn", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_set_causal_attn(llama_context* ctx, [MarshalAs(UnmanagedType.U1)] bool causal_attn);

        [DllImport(__DllName, EntryPoint = "llama_set_abort_callback", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_set_abort_callback(llama_context* ctx, delegate* unmanaged[Cdecl]<void*, bool> abort_callback, void* abort_callback_data);

        [DllImport(__DllName, EntryPoint = "llama_synchronize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_synchronize(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_get_logits", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* llama_get_logits(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_get_logits_ith", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* llama_get_logits_ith(llama_context* ctx, int i);

        [DllImport(__DllName, EntryPoint = "llama_get_embeddings", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* llama_get_embeddings(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_get_embeddings_ith", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* llama_get_embeddings_ith(llama_context* ctx, int i);

        [DllImport(__DllName, EntryPoint = "llama_get_embeddings_seq", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float* llama_get_embeddings_seq(llama_context* ctx, int seq_id);

        [DllImport(__DllName, EntryPoint = "llama_token_get_text", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* llama_token_get_text(llama_model* model, int token);

        [DllImport(__DllName, EntryPoint = "llama_token_get_score", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern float llama_token_get_score(llama_model* model, int token);

        [DllImport(__DllName, EntryPoint = "llama_token_get_type", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern uint llama_token_get_type(llama_model* model, int token);

        [DllImport(__DllName, EntryPoint = "llama_token_bos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_bos(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_eos", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_eos(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_nl", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_nl(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_add_bos_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_add_bos_token(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_add_eos_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_add_eos_token(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_prefix", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_prefix(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_middle", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_middle(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_suffix", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_suffix(llama_model* model);

        [DllImport(__DllName, EntryPoint = "llama_token_eot", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_eot(llama_model* model);

        /// <summary>@details Convert the provided text into tokens. @param tokens The tokens pointer must be large enough to hold the resulting tokens. @return Returns the number of tokens on success, no more than n_tokens_max @return Returns a negative number on failure - the number of tokens that would have been returned @param special Allow tokenizing special and/or control tokens which otherwise are not exposed and treated as plaintext.                Does not insert a leading space.</summary>
        [DllImport(__DllName, EntryPoint = "llama_tokenize", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_tokenize(llama_model* model, byte* text, int text_len, int* tokens, int n_tokens_max, [MarshalAs(UnmanagedType.U1)] bool add_bos, [MarshalAs(UnmanagedType.U1)] bool special);

        [DllImport(__DllName, EntryPoint = "llama_token_to_piece", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_token_to_piece(llama_model* model, int token, byte* buf, int length);

        /// <summary>Apply chat template. Inspired by hf apply_chat_template() on python. Both \"model\" and \"custom_template\" are optional, but at least one is required. \"custom_template\" has higher precedence than \"model\" NOTE: This function does not use a jinja parser. It only support a pre-defined list of template. See more: https://github.com/ggerganov/llama.cpp/wiki/Templates-supported-by-llama_chat_apply_template @param tmpl A Jinja template to use for this chat. If this is nullptr, the model’s default chat template will be used instead. @param chat Pointer to a list of multiple llama_chat_message @param n_msg Number of llama_chat_message in this chat @param add_ass Whether to end the prompt with the token(s) that indicate the start of an assistant message. @param buf A buffer to hold the output formatted prompt. The recommended alloc size is 2 * (total number of characters of all messages) @param length The size of the allocated buffer @return The total number of bytes of the formatted prompt. If is it larger than the size of buffer, you may need to re-alloc it and then re-apply the template.</summary>
        [DllImport(__DllName, EntryPoint = "llama_chat_apply_template", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_chat_apply_template(llama_model* model, byte* tmpl, llama_chat_message* chat, nuint n_msg, [MarshalAs(UnmanagedType.U1)] bool add_ass, byte* buf, int length);

        [DllImport(__DllName, EntryPoint = "llama_grammar_init", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_grammar* llama_grammar_init(llama_grammar_element** rules, nuint n_rules, nuint start_rule_index);

        [DllImport(__DllName, EntryPoint = "llama_grammar_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_grammar_free(llama_grammar* grammar);

        [DllImport(__DllName, EntryPoint = "llama_grammar_copy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_grammar* llama_grammar_copy(llama_grammar* grammar);

        [DllImport(__DllName, EntryPoint = "llama_set_rng_seed", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_set_rng_seed(llama_context* ctx, uint seed);

        /// <summary>@details Repetition penalty described in CTRL academic paper https://arxiv.org/abs/1909.05858, with negative logit fix. @details Frequency and presence penalties described in OpenAI API https://platform.openai.com/docs/api-reference/parameter-details.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_repetition_penalties", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_repetition_penalties(llama_context* ctx, llama_token_data_array* candidates, int* last_tokens, nuint penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present);

        /// <summary>@details Apply classifier-free guidance to the logits as described in academic paper \"Stay on topic with Classifier-Free Guidance\" https://arxiv.org/abs/2306.17806 @param logits Logits extracted from the original generation context. @param logits_guidance Logits extracted from a separate context from the same model. Other than a negative prompt at the beginning, it should have all generated and user input tokens copied from the main context. @param scale Guidance strength. 1.0f means no guidance. Higher values mean stronger guidance.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_apply_guidance", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_apply_guidance(llama_context* ctx, float* logits, float* logits_guidance, float scale);

        /// <summary>@details Sorts candidate tokens by their logits in descending order and calculate probabilities based on logits.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_softmax", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_softmax(llama_context* ctx, llama_token_data_array* candidates);

        /// <summary>@details Top-K sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_top_k", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_top_k(llama_context* ctx, llama_token_data_array* candidates, int k, nuint min_keep);

        /// <summary>@details Nucleus sampling described in academic paper \"The Curious Case of Neural Text Degeneration\" https://arxiv.org/abs/1904.09751</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_top_p", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_top_p(llama_context* ctx, llama_token_data_array* candidates, float p, nuint min_keep);

        /// <summary>@details Minimum P sampling as described in https://github.com/ggerganov/llama.cpp/pull/3841</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_min_p", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_min_p(llama_context* ctx, llama_token_data_array* candidates, float p, nuint min_keep);

        /// <summary>@details Tail Free Sampling described in https://www.trentonbricken.com/Tail-Free-Sampling/.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_tail_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_tail_free(llama_context* ctx, llama_token_data_array* candidates, float z, nuint min_keep);

        /// <summary>@details Locally Typical Sampling implementation described in the paper https://arxiv.org/abs/2202.00666.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_typical", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_typical(llama_context* ctx, llama_token_data_array* candidates, float p, nuint min_keep);

        /// <summary>@details Dynamic temperature implementation described in the paper https://arxiv.org/abs/2309.02772.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_entropy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_entropy(llama_context* ctx, llama_token_data_array* candidates_p, float min_temp, float max_temp, float exponent_val);

        [DllImport(__DllName, EntryPoint = "llama_sample_temp", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_temp(llama_context* ctx, llama_token_data_array* candidates, float temp);

        /// <summary>@details Apply constraints from grammar</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_grammar", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_sample_grammar(llama_context* ctx, llama_token_data_array* candidates, llama_grammar* grammar);

        /// <summary>@details Mirostat 1.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words. @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text. @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text. @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates. @param m The number of tokens considered in the estimation of `s_hat`. This is an arbitrary value that is used to calculate `s_hat`, which in turn helps to calculate the value of `k`. In the paper, they use `m = 100`, but you can experiment with different values to see how it affects the performance of the algorithm. @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_token_mirostat", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_sample_token_mirostat(llama_context* ctx, llama_token_data_array* candidates, float tau, float eta, int m, float* mu);

        /// <summary>@details Mirostat 2.0 algorithm described in the paper https://arxiv.org/abs/2007.14966. Uses tokens instead of words. @param candidates A vector of `llama_token_data` containing the candidate tokens, their probabilities (p), and log-odds (logit) for the current position in the generated text. @param tau  The target cross-entropy (or surprise) value you want to achieve for the generated text. A higher value corresponds to more surprising or less predictable text, while a lower value corresponds to less surprising or more predictable text. @param eta The learning rate used to update `mu` based on the error between the target and observed surprisal of the sampled word. A larger learning rate will cause `mu` to be updated more quickly, while a smaller learning rate will result in slower updates. @param mu Maximum cross-entropy. This value is initialized to be twice the target cross-entropy (`2 * tau`) and is updated in the algorithm based on the error between the target and observed surprisal.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_token_mirostat_v2", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_sample_token_mirostat_v2(llama_context* ctx, llama_token_data_array* candidates, float tau, float eta, float* mu);

        /// <summary>@details Selects the token with the highest probability.          Does not compute the token probabilities. Use llama_sample_softmax() instead.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_token_greedy", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_sample_token_greedy(llama_context* ctx, llama_token_data_array* candidates);

        /// <summary>@details Randomly selects a token from the candidates based on their probabilities.</summary>
        [DllImport(__DllName, EntryPoint = "llama_sample_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_sample_token(llama_context* ctx, llama_token_data_array* candidates);

        /// <summary>@details Accepts the sampled token into the grammar</summary>
        [DllImport(__DllName, EntryPoint = "llama_grammar_accept_token", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_grammar_accept_token(llama_context* ctx, llama_grammar* grammar, int token);

        /// <summary>@details Deterministically returns entire sentence constructed by a beam search. @param ctx Pointer to the llama_context. @param callback Invoked for each iteration of the beam_search loop, passing in beams_state. @param callback_data A pointer that is simply passed back to callback. @param n_beams Number of beams to use. @param n_past Number of tokens already evaluated. @param n_predict Maximum number of tokens to predict. EOS may occur earlier.</summary>
        [DllImport(__DllName, EntryPoint = "llama_beam_search", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_beam_search(llama_context* ctx, delegate* unmanaged[Cdecl]<void*, llama_beams_state, void> callback, void* callback_data, nuint n_beams, int n_past, int n_predict);

        /// <summary>@details Build a split GGUF final path for this chunk.          llama_split_path(split_path, sizeof(split_path), \"/models/ggml-model-q4_0\", 2, 4) =&gt; split_path = \"/models/ggml-model-q4_0-00002-of-00004.gguf\</summary>
        [DllImport(__DllName, EntryPoint = "llama_split_path", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_split_path(byte* split_path, nuint maxlen, byte* path_prefix, int split_no, int split_count);

        /// <summary>@details Extract the path prefix from the split_path if and only if the split_no and split_count match.          llama_split_prefix(split_prefix, 64, \"/models/ggml-model-q4_0-00002-of-00004.gguf\", 2, 4) =&gt; split_prefix = \"/models/ggml-model-q4_0\</summary>
        [DllImport(__DllName, EntryPoint = "llama_split_prefix", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern int llama_split_prefix(byte* split_prefix, nuint maxlen, byte* split_path, int split_no, int split_count);

        [DllImport(__DllName, EntryPoint = "llama_get_timings", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern llama_timings llama_get_timings(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_print_timings", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_print_timings(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_reset_timings", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_reset_timings(llama_context* ctx);

        [DllImport(__DllName, EntryPoint = "llama_print_system_info", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern byte* llama_print_system_info();

        [DllImport(__DllName, EntryPoint = "llama_log_set", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_log_set(delegate* unmanaged[Cdecl]<uint, byte*, void*, void> log_callback, void* user_data);

        [DllImport(__DllName, EntryPoint = "llama_dump_timing_info_yaml", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void llama_dump_timing_info_yaml(__sFILE* stream, llama_context* ctx);


    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct __sbuf
    {
        public byte* _base;
        public int _size;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct __sFILEX
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct __sFILE
    {
        public byte* _p;
        public int _r;
        public int _w;
        public short _flags;
        public short _file;
        public __sbuf _bf;
        public int _lbfsize;
        public void* _cookie;
        public delegate* unmanaged[Cdecl]<void*, int> _close;
        public delegate* unmanaged[Cdecl]<void*, byte*, int, int> _read;
        public delegate* unmanaged[Cdecl]<void*, long, int, long> _seek;
        public delegate* unmanaged[Cdecl]<void*, byte*, int, int> _write;
        public __sbuf _ub;
        public __sFILEX* _extra;
        public int _ur;
        public fixed byte _ubuf[3];
        public fixed byte _nbuf[1];
        public __sbuf _lb;
        public int _blksize;
        public long _offset;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_context
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_object
    {
        public nuint offs;
        public nuint size;
        public ggml_object* next;
        public uint type_;
        public fixed byte padding[4];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_tensor
    {
        public uint type_;
        public uint backend;
        public ggml_backend_buffer* buffer;
        public fixed long ne[4];
        public fixed byte/* nuint, this length is invalid so must keep pointer and can't edit from C# */ nb[4];
        public uint op;
        public fixed int op_params[16];
        public int flags;
        public ggml_tensor* grad;
        public fixed byte/* ggml_tensor, this length is invalid so must keep pointer and can't edit from C# */ src[10];
        public int perf_runs;
        public long perf_cycles;
        public long perf_time_us;
        public ggml_tensor* view_src;
        public nuint view_offs;
        public void* data;
        public fixed byte name[64];
        public void* extra;
        public fixed byte padding[8];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_cplan
    {
        public nuint work_size;
        public byte* work_data;
        public int n_threads;
        public delegate* unmanaged[Cdecl]<void*, bool> abort_callback;
        public void* abort_callback_data;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_hash_set
    {
        public nuint size;
        public ggml_tensor** keys;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_cgraph
    {
        public int size;
        public int n_nodes;
        public int n_leafs;
        public ggml_tensor** nodes;
        public ggml_tensor** grads;
        public ggml_tensor** leafs;
        public ggml_hash_set visited_hash_table;
        public uint order;
        public int perf_runs;
        public long perf_cycles;
        public long perf_time_us;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_scratch
    {
        public nuint offs;
        public nuint size;
        public void* data;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_init_params
    {
        public nuint mem_size;
        public void* mem_buffer;
        [MarshalAs(UnmanagedType.U1)] public bool no_alloc;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_params
    {
        public uint type_;
        public nuint graph_size;
        public int n_threads;
        public int past;
        public float delta;
        public int max_no_improvement;
        [MarshalAs(UnmanagedType.U1)] public bool print_forward_graph;
        [MarshalAs(UnmanagedType.U1)] public bool print_backward_graph;
        public int n_gradient_accumulation;
        public ggml_opt_params__bindgen_ty_1 adam;
        public ggml_opt_params__bindgen_ty_2 lbfgs;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_params__bindgen_ty_1
    {
        public int n_iter;
        public float sched;
        public float decay;
        public int decay_min_ndim;
        public float alpha;
        public float beta1;
        public float beta2;
        public float eps;
        public float eps_f;
        public float eps_g;
        public float gclip;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_params__bindgen_ty_2
    {
        public int m;
        public int n_iter;
        public int max_linesearch;
        public float eps;
        public float ftol;
        public float wolfe;
        public float min_step;
        public float max_step;
        public uint linesearch;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_context
    {
        public ggml_context* ctx;
        public ggml_opt_params @params;
        public int iter;
        public long nx;
        [MarshalAs(UnmanagedType.U1)] public bool just_initialized;
        public float loss_before;
        public float loss_after;
        public ggml_opt_context__bindgen_ty_1 adam;
        public ggml_opt_context__bindgen_ty_2 lbfgs;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_context__bindgen_ty_1
    {
        public ggml_tensor* g;
        public ggml_tensor* m;
        public ggml_tensor* v;
        public ggml_tensor* pf;
        public float fx_best;
        public float fx_prev;
        public int n_no_improvement;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_opt_context__bindgen_ty_2
    {
        public ggml_tensor* x;
        public ggml_tensor* xp;
        public ggml_tensor* g;
        public ggml_tensor* gp;
        public ggml_tensor* d;
        public ggml_tensor* pf;
        public ggml_tensor* lmal;
        public ggml_tensor* lmys;
        public ggml_tensor* lms;
        public ggml_tensor* lmy;
        public float fx_best;
        public float step;
        public int j;
        public int k;
        public int end;
        public int n_no_improvement;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct gguf_context
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct gguf_init_params
    {
        [MarshalAs(UnmanagedType.U1)] public bool no_alloc;
        public ggml_context** ctx;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_type_traits_t
    {
        public byte* type_name;
        public int blck_size;
        public nuint type_size;
        [MarshalAs(UnmanagedType.U1)] public bool is_quantized;
        public delegate* unmanaged[Cdecl]<void*, float*, int, void> to_float;
        public delegate* unmanaged[Cdecl]<float*, void*, int, void> from_float;
        public delegate* unmanaged[Cdecl]<float*, void*, int, void> from_float_reference;
        public delegate* unmanaged[Cdecl]<int, float*, nuint, void*, nuint, void*, nuint, int, void> vec_dot;
        public uint vec_dot_type;
        public long nrows;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend_buffer_type
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_tallocr
    {
        public ggml_backend_buffer* buffer;
        public void* @base;
        public nuint alignment;
        public nuint offset;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_gallocr
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend_event
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend_sched
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend_graph_copy
    {
        public ggml_backend_buffer* buffer;
        public ggml_context* ctx_allocated;
        public ggml_context* ctx_unallocated;
        public ggml_cgraph* graph;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_model
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_context
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_token_data
    {
        public int id;
        public float logit;
        public float p;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_token_data_array
    {
        public llama_token_data* data;
        public nuint size;
        [MarshalAs(UnmanagedType.U1)] public bool sorted;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_batch
    {
        public int n_tokens;
        public int* token;
        public float* embd;
        public int* pos;
        public int* n_seq_id;
        public int** seq_id;
        public sbyte* logits;
        public int all_pos_0;
        public int all_pos_1;
        public int all_seq_id;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_model_kv_override
    {
        public fixed byte key[128];
        public uint tag;
        public llama_model_kv_override__bindgen_ty_1 __bindgen_anon_1;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal unsafe partial struct llama_model_kv_override__bindgen_ty_1
    {
        [FieldOffset(0)]
        public long int_value;
        [FieldOffset(0)]
        public double float_value;
        [FieldOffset(0)]
        [MarshalAs(UnmanagedType.U1)] public bool bool_value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_model_params
    {
        public int n_gpu_layers;
        public uint split_mode;
        public int main_gpu;
        public float* tensor_split;
        public delegate* unmanaged[Cdecl]<float, void*, bool> progress_callback;
        public void* progress_callback_user_data;
        public llama_model_kv_override* kv_overrides;
        [MarshalAs(UnmanagedType.U1)] public bool vocab_only;
        [MarshalAs(UnmanagedType.U1)] public bool use_mmap;
        [MarshalAs(UnmanagedType.U1)] public bool use_mlock;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_context_params
    {
        public uint seed;
        public uint n_ctx;
        public uint n_batch;
        public uint n_ubatch;
        public uint n_seq_max;
        public uint n_threads;
        public uint n_threads_batch;
        public int rope_scaling_type;
        public int pooling_type;
        public float rope_freq_base;
        public float rope_freq_scale;
        public float yarn_ext_factor;
        public float yarn_attn_factor;
        public float yarn_beta_fast;
        public float yarn_beta_slow;
        public uint yarn_orig_ctx;
        public float defrag_thold;
        public delegate* unmanaged[Cdecl]<ggml_tensor*, bool, void*, bool> cb_eval;
        public void* cb_eval_user_data;
        public uint type_k;
        public uint type_v;
        [MarshalAs(UnmanagedType.U1)] public bool logits_all;
        [MarshalAs(UnmanagedType.U1)] public bool embeddings;
        [MarshalAs(UnmanagedType.U1)] public bool offload_kqv;
        public delegate* unmanaged[Cdecl]<void*, bool> abort_callback;
        public void* abort_callback_data;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_model_quantize_params
    {
        public int nthread;
        public uint ftype;
        public uint output_tensor_type;
        public uint token_embedding_type;
        [MarshalAs(UnmanagedType.U1)] public bool allow_requantize;
        [MarshalAs(UnmanagedType.U1)] public bool quantize_output_tensor;
        [MarshalAs(UnmanagedType.U1)] public bool only_copy;
        [MarshalAs(UnmanagedType.U1)] public bool pure_;
        public void* imatrix;
        public void* kv_overrides;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_grammar
    {
        public fixed byte _unused[1];
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_grammar_element
    {
        public uint type_;
        public uint value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_timings
    {
        public double t_start_ms;
        public double t_end_ms;
        public double t_load_ms;
        public double t_sample_ms;
        public double t_p_eval_ms;
        public double t_eval_ms;
        public int n_sample;
        public int n_p_eval;
        public int n_eval;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_chat_message
    {
        public byte* role;
        public byte* content;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_kv_cache_view_cell
    {
        public int pos;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_kv_cache_view
    {
        public int n_cells;
        public int n_seq_max;
        public int token_count;
        public int used_cells;
        public int max_contiguous;
        public int max_contiguous_idx;
        public llama_kv_cache_view_cell* cells;
        public int* cells_sequences;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_beam_view
    {
        public int* tokens;
        public nuint n_tokens;
        public float p;
        [MarshalAs(UnmanagedType.U1)] public bool eob;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct llama_beams_state
    {
        public llama_beam_view* beam_views;
        public nuint n_beams;
        public nuint common_prefix_length;
        [MarshalAs(UnmanagedType.U1)] public bool last_call;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal unsafe partial struct ggml_backend_buffer
    {
        public byte _address;
    }



}
