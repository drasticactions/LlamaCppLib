/* automatically generated by csbindgen */

#[allow(unused)]
use ::std::os::raw::*;

use super::llama::*;


#[no_mangle]
pub unsafe extern "C" fn csbindgen_renameat(
    arg1: c_int,
    arg2: *const c_char,
    arg3: c_int,
    arg4: *const c_char
) -> c_int
{
    renameat(
        arg1,
        arg2,
        arg3,
        arg4
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_renamex_np(
    arg1: *const c_char,
    arg2: *const c_char,
    arg3: c_uint
) -> c_int
{
    renamex_np(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_renameatx_np(
    arg1: c_int,
    arg2: *const c_char,
    arg3: c_int,
    arg4: *const c_char,
    arg5: c_uint
) -> c_int
{
    renameatx_np(
        arg1,
        arg2,
        arg3,
        arg4,
        arg5
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_clearerr(
    arg1: *mut FILE
)
{
    clearerr(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fclose(
    arg1: *mut FILE
) -> c_int
{
    fclose(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_feof(
    arg1: *mut FILE
) -> c_int
{
    feof(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ferror(
    arg1: *mut FILE
) -> c_int
{
    ferror(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fflush(
    arg1: *mut FILE
) -> c_int
{
    fflush(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fgetc(
    arg1: *mut FILE
) -> c_int
{
    fgetc(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fgetpos(
    arg1: *mut FILE,
    arg2: *mut fpos_t
) -> c_int
{
    fgetpos(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fgets(
    arg1: *mut c_char,
    arg2: c_int,
    arg3: *mut FILE
) -> *mut c_char
{
    fgets(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fopen(
    __filename: *const c_char,
    __mode: *const c_char
) -> *mut FILE
{
    fopen(
        __filename,
        __mode
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fprintf(
    arg1: *mut FILE,
    arg2: *const c_char
) -> c_int
{
    fprintf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fputc(
    arg1: c_int,
    arg2: *mut FILE
) -> c_int
{
    fputc(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fputs(
    arg1: *const c_char,
    arg2: *mut FILE
) -> c_int
{
    fputs(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fread(
    __ptr: *mut c_void,
    __size: c_ulong,
    __nitems: c_ulong,
    __stream: *mut FILE
) -> c_ulong
{
    fread(
        __ptr,
        __size,
        __nitems,
        __stream
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_freopen(
    arg1: *const c_char,
    arg2: *const c_char,
    arg3: *mut FILE
) -> *mut FILE
{
    freopen(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fscanf(
    arg1: *mut FILE,
    arg2: *const c_char
) -> c_int
{
    fscanf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fseek(
    arg1: *mut FILE,
    arg2: c_long,
    arg3: c_int
) -> c_int
{
    fseek(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fsetpos(
    arg1: *mut FILE,
    arg2: *const fpos_t
) -> c_int
{
    fsetpos(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ftell(
    arg1: *mut FILE
) -> c_long
{
    ftell(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fwrite(
    __ptr: *const c_void,
    __size: c_ulong,
    __nitems: c_ulong,
    __stream: *mut FILE
) -> c_ulong
{
    fwrite(
        __ptr,
        __size,
        __nitems,
        __stream
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getc(
    arg1: *mut FILE
) -> c_int
{
    getc(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getchar(

) -> c_int
{
    getchar(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gets(
    arg1: *mut c_char
) -> *mut c_char
{
    gets(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_perror(
    arg1: *const c_char
)
{
    perror(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_printf(
    arg1: *const c_char
) -> c_int
{
    printf(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_putc(
    arg1: c_int,
    arg2: *mut FILE
) -> c_int
{
    putc(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_putchar(
    arg1: c_int
) -> c_int
{
    putchar(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_puts(
    arg1: *const c_char
) -> c_int
{
    puts(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_remove(
    arg1: *const c_char
) -> c_int
{
    remove(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_rename(
    __old: *const c_char,
    __new: *const c_char
) -> c_int
{
    rename(
        __old,
        __new
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_rewind(
    arg1: *mut FILE
)
{
    rewind(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_scanf(
    arg1: *const c_char
) -> c_int
{
    scanf(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_setbuf(
    arg1: *mut FILE,
    arg2: *mut c_char
)
{
    setbuf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_setvbuf(
    arg1: *mut FILE,
    arg2: *mut c_char,
    arg3: c_int,
    arg4: usize
) -> c_int
{
    setvbuf(
        arg1,
        arg2,
        arg3,
        arg4
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sprintf(
    arg1: *mut c_char,
    arg2: *const c_char
) -> c_int
{
    sprintf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_sscanf(
    arg1: *const c_char,
    arg2: *const c_char
) -> c_int
{
    sscanf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_tmpfile(

) -> *mut FILE
{
    tmpfile(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_tmpnam(
    arg1: *mut c_char
) -> *mut c_char
{
    tmpnam(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ungetc(
    arg1: c_int,
    arg2: *mut FILE
) -> c_int
{
    ungetc(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vfprintf(
    arg1: *mut FILE,
    arg2: *const c_char,
    arg3: __builtin_va_list
) -> c_int
{
    vfprintf(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vprintf(
    arg1: *const c_char,
    arg2: __builtin_va_list
) -> c_int
{
    vprintf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vsprintf(
    arg1: *mut c_char,
    arg2: *const c_char,
    arg3: __builtin_va_list
) -> c_int
{
    vsprintf(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ctermid(
    arg1: *mut c_char
) -> *mut c_char
{
    ctermid(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fdopen(
    arg1: c_int,
    arg2: *const c_char
) -> *mut FILE
{
    fdopen(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fileno(
    arg1: *mut FILE
) -> c_int
{
    fileno(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_pclose(
    arg1: *mut FILE
) -> c_int
{
    pclose(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_popen(
    arg1: *const c_char,
    arg2: *const c_char
) -> *mut FILE
{
    popen(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_flockfile(
    arg1: *mut FILE
)
{
    flockfile(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ftrylockfile(
    arg1: *mut FILE
) -> c_int
{
    ftrylockfile(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_funlockfile(
    arg1: *mut FILE
)
{
    funlockfile(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getc_unlocked(
    arg1: *mut FILE
) -> c_int
{
    getc_unlocked(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getchar_unlocked(

) -> c_int
{
    getchar_unlocked(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_putc_unlocked(
    arg1: c_int,
    arg2: *mut FILE
) -> c_int
{
    putc_unlocked(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_putchar_unlocked(
    arg1: c_int
) -> c_int
{
    putchar_unlocked(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getw(
    arg1: *mut FILE
) -> c_int
{
    getw(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_putw(
    arg1: c_int,
    arg2: *mut FILE
) -> c_int
{
    putw(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_tempnam(
    __dir: *const c_char,
    __prefix: *const c_char
) -> *mut c_char
{
    tempnam(
        __dir,
        __prefix
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fseeko(
    __stream: *mut FILE,
    __offset: off_t,
    __whence: c_int
) -> c_int
{
    fseeko(
        __stream,
        __offset,
        __whence
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ftello(
    __stream: *mut FILE
) -> off_t
{
    ftello(
        __stream
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_snprintf(
    __str: *mut c_char,
    __size: c_ulong,
    __format: *const c_char
) -> c_int
{
    snprintf(
        __str,
        __size,
        __format
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vfscanf(
    __stream: *mut FILE,
    __format: *const c_char,
    arg1: __builtin_va_list
) -> c_int
{
    vfscanf(
        __stream,
        __format,
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vscanf(
    __format: *const c_char,
    arg1: __builtin_va_list
) -> c_int
{
    vscanf(
        __format,
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vsnprintf(
    __str: *mut c_char,
    __size: c_ulong,
    __format: *const c_char,
    arg1: __builtin_va_list
) -> c_int
{
    vsnprintf(
        __str,
        __size,
        __format,
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vsscanf(
    __str: *const c_char,
    __format: *const c_char,
    arg1: __builtin_va_list
) -> c_int
{
    vsscanf(
        __str,
        __format,
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_dprintf(
    arg1: c_int,
    arg2: *const c_char
) -> c_int
{
    dprintf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vdprintf(
    arg1: c_int,
    arg2: *const c_char,
    arg3: va_list
) -> c_int
{
    vdprintf(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getdelim(
    __linep: *mut *mut c_char,
    __linecapp: *mut usize,
    __delimiter: c_int,
    __stream: *mut FILE
) -> isize
{
    getdelim(
        __linep,
        __linecapp,
        __delimiter,
        __stream
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_getline(
    __linep: *mut *mut c_char,
    __linecapp: *mut usize,
    __stream: *mut FILE
) -> isize
{
    getline(
        __linep,
        __linecapp,
        __stream
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fmemopen(
    __buf: *mut c_void,
    __size: usize,
    __mode: *const c_char
) -> *mut FILE
{
    fmemopen(
        __buf,
        __size,
        __mode
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_open_memstream(
    __bufp: *mut *mut c_char,
    __sizep: *mut usize
) -> *mut FILE
{
    open_memstream(
        __bufp,
        __sizep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_asprintf(
    arg1: *mut *mut c_char,
    arg2: *const c_char
) -> c_int
{
    asprintf(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ctermid_r(
    arg1: *mut c_char
) -> *mut c_char
{
    ctermid_r(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fgetln(
    arg1: *mut FILE,
    arg2: *mut usize
) -> *mut c_char
{
    fgetln(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fmtcheck(
    arg1: *const c_char,
    arg2: *const c_char
) -> *const c_char
{
    fmtcheck(
        arg1,
        arg2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_fpurge(
    arg1: *mut FILE
) -> c_int
{
    fpurge(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_setbuffer(
    arg1: *mut FILE,
    arg2: *mut c_char,
    arg3: c_int
)
{
    setbuffer(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_setlinebuf(
    arg1: *mut FILE
) -> c_int
{
    setlinebuf(
        arg1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_vasprintf(
    arg1: *mut *mut c_char,
    arg2: *const c_char,
    arg3: va_list
) -> c_int
{
    vasprintf(
        arg1,
        arg2,
        arg3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_funopen(
    arg1: *const c_void,
    arg2: Option<unsafe extern "C" fn(arg1: *mut c_void, arg2: *mut c_char, arg3: c_int) -> c_int>,
    arg3: Option<unsafe extern "C" fn(arg1: *mut c_void, arg2: *const c_char, arg3: c_int) -> c_int>,
    arg4: Option<unsafe extern "C" fn(arg1: *mut c_void, arg2: fpos_t, arg3: c_int) -> fpos_t>,
    arg5: Option<unsafe extern "C" fn(arg1: *mut c_void) -> c_int>
) -> *mut FILE
{
    funopen(
        arg1,
        arg2,
        arg3,
        arg4,
        arg5
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_status_to_string(
    status: ggml_status
) -> *const c_char
{
    ggml_status_to_string(
        status
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_fp16_to_fp32(
    x: ggml_fp16_t
) -> f32
{
    ggml_fp16_to_fp32(
        x
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_fp32_to_fp16(
    x: f32
) -> ggml_fp16_t
{
    ggml_fp32_to_fp16(
        x
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_fp16_to_fp32_row(
    x: *const ggml_fp16_t,
    y: *mut f32,
    n: c_int
)
{
    ggml_fp16_to_fp32_row(
        x,
        y,
        n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_fp32_to_fp16_row(
    x: *const f32,
    y: *mut ggml_fp16_t,
    n: c_int
)
{
    ggml_fp32_to_fp16_row(
        x,
        y,
        n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_guid_matches(
    guid_a: ggml_guid_t,
    guid_b: ggml_guid_t
) -> bool
{
    ggml_guid_matches(
        guid_a,
        guid_b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_time_init(

)
{
    ggml_time_init(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_time_ms(

) -> i64
{
    ggml_time_ms(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_time_us(

) -> i64
{
    ggml_time_us(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cycles(

) -> i64
{
    ggml_cycles(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cycles_per_ms(

) -> i64
{
    ggml_cycles_per_ms(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_print_backtrace(

)
{
    ggml_print_backtrace(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_fopen(
    fname: *const c_char,
    mode: *const c_char
) -> *mut FILE
{
    ggml_fopen(
        fname,
        mode
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_numa_init(
    numa: ggml_numa_strategy
)
{
    ggml_numa_init(
        numa
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_numa(

) -> bool
{
    ggml_is_numa(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_print_object(
    obj: *const ggml_object
)
{
    ggml_print_object(
        obj
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_print_objects(
    ctx: *const ggml_context
)
{
    ggml_print_objects(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_nelements(
    tensor: *const ggml_tensor
) -> i64
{
    ggml_nelements(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_nrows(
    tensor: *const ggml_tensor
) -> i64
{
    ggml_nrows(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_nbytes(
    tensor: *const ggml_tensor
) -> usize
{
    ggml_nbytes(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_nbytes_pad(
    tensor: *const ggml_tensor
) -> usize
{
    ggml_nbytes_pad(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_blck_size(
    type_: ggml_type
) -> c_int
{
    ggml_blck_size(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_type_size(
    type_: ggml_type
) -> usize
{
    ggml_type_size(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_row_size(
    type_: ggml_type,
    ne: i64
) -> usize
{
    ggml_row_size(
        type_,
        ne
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_type_sizef(
    type_: ggml_type
) -> f64
{
    ggml_type_sizef(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_type_name(
    type_: ggml_type
) -> *const c_char
{
    ggml_type_name(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_op_name(
    op: ggml_op
) -> *const c_char
{
    ggml_op_name(
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_op_symbol(
    op: ggml_op
) -> *const c_char
{
    ggml_op_symbol(
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_unary_op_name(
    op: ggml_unary_op
) -> *const c_char
{
    ggml_unary_op_name(
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_op_desc(
    t: *const ggml_tensor
) -> *const c_char
{
    ggml_op_desc(
        t
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_element_size(
    tensor: *const ggml_tensor
) -> usize
{
    ggml_element_size(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_quantized(
    type_: ggml_type
) -> bool
{
    ggml_is_quantized(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_ftype_to_ggml_type(
    ftype: ggml_ftype
) -> ggml_type
{
    ggml_ftype_to_ggml_type(
        ftype
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_transposed(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_transposed(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_contiguous(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_contiguous(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_permuted(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_permuted(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_empty(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_empty(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_scalar(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_scalar(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_vector(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_vector(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_matrix(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_matrix(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_is_3d(
    tensor: *const ggml_tensor
) -> bool
{
    ggml_is_3d(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_n_dims(
    tensor: *const ggml_tensor
) -> c_int
{
    ggml_n_dims(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_are_same_shape(
    t0: *const ggml_tensor,
    t1: *const ggml_tensor
) -> bool
{
    ggml_are_same_shape(
        t0,
        t1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_tensor_overhead(

) -> usize
{
    ggml_tensor_overhead(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_init(
    params: ggml_init_params
) -> *mut ggml_context
{
    ggml_init(
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_free(
    ctx: *mut ggml_context
)
{
    ggml_free(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_used_mem(
    ctx: *const ggml_context
) -> usize
{
    ggml_used_mem(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_scratch(
    ctx: *mut ggml_context,
    scratch: ggml_scratch
) -> usize
{
    ggml_set_scratch(
        ctx,
        scratch
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_no_alloc(
    ctx: *mut ggml_context
) -> bool
{
    ggml_get_no_alloc(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_no_alloc(
    ctx: *mut ggml_context,
    no_alloc: bool
)
{
    ggml_set_no_alloc(
        ctx,
        no_alloc
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_mem_buffer(
    ctx: *const ggml_context
) -> *mut c_void
{
    ggml_get_mem_buffer(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_mem_size(
    ctx: *const ggml_context
) -> usize
{
    ggml_get_mem_size(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_max_tensor_size(
    ctx: *const ggml_context
) -> usize
{
    ggml_get_max_tensor_size(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_tensor(
    ctx: *mut ggml_context,
    type_: ggml_type,
    n_dims: c_int,
    ne: *const i64
) -> *mut ggml_tensor
{
    ggml_new_tensor(
        ctx,
        type_,
        n_dims,
        ne
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_tensor_1d(
    ctx: *mut ggml_context,
    type_: ggml_type,
    ne0: i64
) -> *mut ggml_tensor
{
    ggml_new_tensor_1d(
        ctx,
        type_,
        ne0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_tensor_2d(
    ctx: *mut ggml_context,
    type_: ggml_type,
    ne0: i64,
    ne1: i64
) -> *mut ggml_tensor
{
    ggml_new_tensor_2d(
        ctx,
        type_,
        ne0,
        ne1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_tensor_3d(
    ctx: *mut ggml_context,
    type_: ggml_type,
    ne0: i64,
    ne1: i64,
    ne2: i64
) -> *mut ggml_tensor
{
    ggml_new_tensor_3d(
        ctx,
        type_,
        ne0,
        ne1,
        ne2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_tensor_4d(
    ctx: *mut ggml_context,
    type_: ggml_type,
    ne0: i64,
    ne1: i64,
    ne2: i64,
    ne3: i64
) -> *mut ggml_tensor
{
    ggml_new_tensor_4d(
        ctx,
        type_,
        ne0,
        ne1,
        ne2,
        ne3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_i32(
    ctx: *mut ggml_context,
    value: i32
) -> *mut ggml_tensor
{
    ggml_new_i32(
        ctx,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_f32(
    ctx: *mut ggml_context,
    value: f32
) -> *mut ggml_tensor
{
    ggml_new_f32(
        ctx,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_dup_tensor(
    ctx: *mut ggml_context,
    src: *const ggml_tensor
) -> *mut ggml_tensor
{
    ggml_dup_tensor(
        ctx,
        src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_view_tensor(
    ctx: *mut ggml_context,
    src: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_view_tensor(
        ctx,
        src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_first_tensor(
    ctx: *const ggml_context
) -> *mut ggml_tensor
{
    ggml_get_first_tensor(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_next_tensor(
    ctx: *const ggml_context,
    tensor: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_get_next_tensor(
        ctx,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_tensor(
    ctx: *mut ggml_context,
    name: *const c_char
) -> *mut ggml_tensor
{
    ggml_get_tensor(
        ctx,
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_zero(
    tensor: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_set_zero(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_i32(
    tensor: *mut ggml_tensor,
    value: i32
) -> *mut ggml_tensor
{
    ggml_set_i32(
        tensor,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_f32(
    tensor: *mut ggml_tensor,
    value: f32
) -> *mut ggml_tensor
{
    ggml_set_f32(
        tensor,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_unravel_index(
    tensor: *const ggml_tensor,
    i: i64,
    i0: *mut i64,
    i1: *mut i64,
    i2: *mut i64,
    i3: *mut i64
)
{
    ggml_unravel_index(
        tensor,
        i,
        i0,
        i1,
        i2,
        i3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_i32_1d(
    tensor: *const ggml_tensor,
    i: c_int
) -> i32
{
    ggml_get_i32_1d(
        tensor,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_i32_1d(
    tensor: *const ggml_tensor,
    i: c_int,
    value: i32
)
{
    ggml_set_i32_1d(
        tensor,
        i,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_i32_nd(
    tensor: *const ggml_tensor,
    i0: c_int,
    i1: c_int,
    i2: c_int,
    i3: c_int
) -> i32
{
    ggml_get_i32_nd(
        tensor,
        i0,
        i1,
        i2,
        i3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_i32_nd(
    tensor: *const ggml_tensor,
    i0: c_int,
    i1: c_int,
    i2: c_int,
    i3: c_int,
    value: i32
)
{
    ggml_set_i32_nd(
        tensor,
        i0,
        i1,
        i2,
        i3,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_f32_1d(
    tensor: *const ggml_tensor,
    i: c_int
) -> f32
{
    ggml_get_f32_1d(
        tensor,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_f32_1d(
    tensor: *const ggml_tensor,
    i: c_int,
    value: f32
)
{
    ggml_set_f32_1d(
        tensor,
        i,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_f32_nd(
    tensor: *const ggml_tensor,
    i0: c_int,
    i1: c_int,
    i2: c_int,
    i3: c_int
) -> f32
{
    ggml_get_f32_nd(
        tensor,
        i0,
        i1,
        i2,
        i3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_f32_nd(
    tensor: *const ggml_tensor,
    i0: c_int,
    i1: c_int,
    i2: c_int,
    i3: c_int,
    value: f32
)
{
    ggml_set_f32_nd(
        tensor,
        i0,
        i1,
        i2,
        i3,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_data(
    tensor: *const ggml_tensor
) -> *mut c_void
{
    ggml_get_data(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_data_f32(
    tensor: *const ggml_tensor
) -> *mut f32
{
    ggml_get_data_f32(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_unary_op(
    tensor: *const ggml_tensor
) -> ggml_unary_op
{
    ggml_get_unary_op(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_name(
    tensor: *const ggml_tensor
) -> *const c_char
{
    ggml_get_name(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_name(
    tensor: *mut ggml_tensor,
    name: *const c_char
) -> *mut ggml_tensor
{
    ggml_set_name(
        tensor,
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_format_name(
    tensor: *mut ggml_tensor,
    fmt: *const c_char
) -> *mut ggml_tensor
{
    ggml_format_name(
        tensor,
        fmt
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_dup(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_dup(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_dup_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_dup_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add_cast(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    type_: ggml_type
) -> *mut ggml_tensor
{
    ggml_add_cast(
        ctx,
        a,
        b,
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add1(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add1(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add1_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add1_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_acc(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    nb2: usize,
    nb3: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_acc(
        ctx,
        a,
        b,
        nb1,
        nb2,
        nb3,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_acc_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    nb2: usize,
    nb3: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_acc_inplace(
        ctx,
        a,
        b,
        nb1,
        nb2,
        nb3,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sub(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sub(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sub_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sub_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mul(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_mul(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mul_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_mul_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_div(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_div(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_div_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_div_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sqr(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sqr(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sqr_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sqr_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sqrt(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sqrt(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sqrt_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sqrt_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_log(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_log(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_log_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_log_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sum(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sum(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sum_rows(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sum_rows(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mean(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_mean(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_argmax(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_argmax(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_repeat(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_repeat(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_repeat_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_repeat_back(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_concat(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_concat(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_abs(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_abs(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_abs_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_abs_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sgn(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sgn(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_sgn_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_sgn_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_neg(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_neg(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_neg_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_neg_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_step(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_step(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_step_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_step_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_tanh(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_tanh(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_tanh_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_tanh_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_elu(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_elu(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_elu_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_elu_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_relu(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_relu(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_leaky_relu(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    negative_slope: f32,
    inplace: bool
) -> *mut ggml_tensor
{
    ggml_leaky_relu(
        ctx,
        a,
        negative_slope,
        inplace
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_relu_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_relu_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gelu(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_gelu(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gelu_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_gelu_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gelu_quick(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_gelu_quick(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gelu_quick_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_gelu_quick_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_silu(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_silu(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_silu_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_silu_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_silu_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_silu_back(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_hardswish(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_hardswish(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_hardsigmoid(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_hardsigmoid(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_norm(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    eps: f32
) -> *mut ggml_tensor
{
    ggml_norm(
        ctx,
        a,
        eps
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_norm_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    eps: f32
) -> *mut ggml_tensor
{
    ggml_norm_inplace(
        ctx,
        a,
        eps
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rms_norm(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    eps: f32
) -> *mut ggml_tensor
{
    ggml_rms_norm(
        ctx,
        a,
        eps
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rms_norm_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    eps: f32
) -> *mut ggml_tensor
{
    ggml_rms_norm_inplace(
        ctx,
        a,
        eps
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_group_norm(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_groups: c_int
) -> *mut ggml_tensor
{
    ggml_group_norm(
        ctx,
        a,
        n_groups
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_group_norm_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_groups: c_int
) -> *mut ggml_tensor
{
    ggml_group_norm_inplace(
        ctx,
        a,
        n_groups
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rms_norm_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    eps: f32
) -> *mut ggml_tensor
{
    ggml_rms_norm_back(
        ctx,
        a,
        b,
        eps
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mul_mat(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_mul_mat(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mul_mat_set_prec(
    a: *mut ggml_tensor,
    prec: ggml_prec
)
{
    ggml_mul_mat_set_prec(
        a,
        prec
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_mul_mat_id(
    ctx: *mut ggml_context,
    as_: *const *mut ggml_tensor,
    n_as: c_int,
    ids: *mut ggml_tensor,
    id: c_int,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_mul_mat_id(
        ctx,
        as_,
        n_as,
        ids,
        id,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_out_prod(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_out_prod(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_scale(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    s: f32
) -> *mut ggml_tensor
{
    ggml_scale(
        ctx,
        a,
        s
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_scale_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    s: f32
) -> *mut ggml_tensor
{
    ggml_scale_inplace(
        ctx,
        a,
        s
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    nb2: usize,
    nb3: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set(
        ctx,
        a,
        b,
        nb1,
        nb2,
        nb3,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    nb2: usize,
    nb3: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set_inplace(
        ctx,
        a,
        b,
        nb1,
        nb2,
        nb3,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set_1d(
        ctx,
        a,
        b,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_1d_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set_1d_inplace(
        ctx,
        a,
        b,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set_2d(
        ctx,
        a,
        b,
        nb1,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_2d_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    nb1: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_set_2d_inplace(
        ctx,
        a,
        b,
        nb1,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpy(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_cpy(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cast(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    type_: ggml_type
) -> *mut ggml_tensor
{
    ggml_cast(
        ctx,
        a,
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cont(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_cont(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cont_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64
) -> *mut ggml_tensor
{
    ggml_cont_1d(
        ctx,
        a,
        ne0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cont_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64
) -> *mut ggml_tensor
{
    ggml_cont_2d(
        ctx,
        a,
        ne0,
        ne1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cont_3d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64
) -> *mut ggml_tensor
{
    ggml_cont_3d(
        ctx,
        a,
        ne0,
        ne1,
        ne2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cont_4d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64,
    ne3: i64
) -> *mut ggml_tensor
{
    ggml_cont_4d(
        ctx,
        a,
        ne0,
        ne1,
        ne2,
        ne3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_reshape(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_reshape(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_reshape_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64
) -> *mut ggml_tensor
{
    ggml_reshape_1d(
        ctx,
        a,
        ne0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_reshape_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64
) -> *mut ggml_tensor
{
    ggml_reshape_2d(
        ctx,
        a,
        ne0,
        ne1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_reshape_3d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64
) -> *mut ggml_tensor
{
    ggml_reshape_3d(
        ctx,
        a,
        ne0,
        ne1,
        ne2
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_reshape_4d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64,
    ne3: i64
) -> *mut ggml_tensor
{
    ggml_reshape_4d(
        ctx,
        a,
        ne0,
        ne1,
        ne2,
        ne3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_view_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_view_1d(
        ctx,
        a,
        ne0,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_view_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    nb1: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_view_2d(
        ctx,
        a,
        ne0,
        ne1,
        nb1,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_view_3d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64,
    nb1: usize,
    nb2: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_view_3d(
        ctx,
        a,
        ne0,
        ne1,
        ne2,
        nb1,
        nb2,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_view_4d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    ne0: i64,
    ne1: i64,
    ne2: i64,
    ne3: i64,
    nb1: usize,
    nb2: usize,
    nb3: usize,
    offset: usize
) -> *mut ggml_tensor
{
    ggml_view_4d(
        ctx,
        a,
        ne0,
        ne1,
        ne2,
        ne3,
        nb1,
        nb2,
        nb3,
        offset
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_permute(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    axis0: c_int,
    axis1: c_int,
    axis2: c_int,
    axis3: c_int
) -> *mut ggml_tensor
{
    ggml_permute(
        ctx,
        a,
        axis0,
        axis1,
        axis2,
        axis3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_transpose(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_transpose(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_rows(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_get_rows(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_rows_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_get_rows_back(
        ctx,
        a,
        b,
        c
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_diag(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_diag(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_diag_mask_inf(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_past: c_int
) -> *mut ggml_tensor
{
    ggml_diag_mask_inf(
        ctx,
        a,
        n_past
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_diag_mask_inf_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_past: c_int
) -> *mut ggml_tensor
{
    ggml_diag_mask_inf_inplace(
        ctx,
        a,
        n_past
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_diag_mask_zero(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_past: c_int
) -> *mut ggml_tensor
{
    ggml_diag_mask_zero(
        ctx,
        a,
        n_past
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_diag_mask_zero_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_past: c_int
) -> *mut ggml_tensor
{
    ggml_diag_mask_zero_inplace(
        ctx,
        a,
        n_past
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_soft_max(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_soft_max(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_soft_max_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_soft_max_inplace(
        ctx,
        a
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_soft_max_ext(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    mask: *mut ggml_tensor,
    pos: *mut ggml_tensor,
    scale: f32,
    max_bias: f32
) -> *mut ggml_tensor
{
    ggml_soft_max_ext(
        ctx,
        a,
        mask,
        pos,
        scale,
        max_bias
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_soft_max_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_soft_max_back(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_soft_max_back_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_soft_max_back_inplace(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    mode: c_int,
    n_ctx: c_int
) -> *mut ggml_tensor
{
    ggml_rope(
        ctx,
        a,
        b,
        n_dims,
        mode,
        n_ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    mode: c_int,
    n_ctx: c_int
) -> *mut ggml_tensor
{
    ggml_rope_inplace(
        ctx,
        a,
        b,
        n_dims,
        mode,
        n_ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_custom(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    mode: c_int,
    n_ctx: c_int,
    n_orig_ctx: c_int,
    freq_base: f32,
    freq_scale: f32,
    ext_factor: f32,
    attn_factor: f32,
    beta_fast: f32,
    beta_slow: f32
) -> *mut ggml_tensor
{
    ggml_rope_custom(
        ctx,
        a,
        b,
        n_dims,
        mode,
        n_ctx,
        n_orig_ctx,
        freq_base,
        freq_scale,
        ext_factor,
        attn_factor,
        beta_fast,
        beta_slow
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_custom_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    mode: c_int,
    n_ctx: c_int,
    n_orig_ctx: c_int,
    freq_base: f32,
    freq_scale: f32,
    ext_factor: f32,
    attn_factor: f32,
    beta_fast: f32,
    beta_slow: f32
) -> *mut ggml_tensor
{
    ggml_rope_custom_inplace(
        ctx,
        a,
        b,
        n_dims,
        mode,
        n_ctx,
        n_orig_ctx,
        freq_base,
        freq_scale,
        ext_factor,
        attn_factor,
        beta_fast,
        beta_slow
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_yarn_corr_dims(
    n_dims: c_int,
    n_orig_ctx: c_int,
    freq_base: f32,
    beta_fast: f32,
    beta_slow: f32,
    dims: *mut f32
)
{
    ggml_rope_yarn_corr_dims(
        n_dims,
        n_orig_ctx,
        freq_base,
        beta_fast,
        beta_slow,
        dims
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_xpos_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    base: f32,
    down: bool
) -> *mut ggml_tensor
{
    ggml_rope_xpos_inplace(
        ctx,
        a,
        b,
        n_dims,
        base,
        down
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_rope_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    n_dims: c_int,
    mode: c_int,
    n_ctx: c_int,
    n_orig_ctx: c_int,
    freq_base: f32,
    freq_scale: f32,
    ext_factor: f32,
    attn_factor: f32,
    beta_fast: f32,
    beta_slow: f32,
    xpos_base: f32,
    xpos_down: bool
) -> *mut ggml_tensor
{
    ggml_rope_back(
        ctx,
        a,
        b,
        n_dims,
        mode,
        n_ctx,
        n_orig_ctx,
        freq_base,
        freq_scale,
        ext_factor,
        attn_factor,
        beta_fast,
        beta_slow,
        xpos_base,
        xpos_down
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_alibi(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    n_past: c_int,
    n_head: c_int,
    bias_max: f32
) -> *mut ggml_tensor
{
    ggml_alibi(
        ctx,
        a,
        n_past,
        n_head,
        bias_max
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_clamp(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    min: f32,
    max: f32
) -> *mut ggml_tensor
{
    ggml_clamp(
        ctx,
        a,
        min,
        max
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_im2col(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s0: c_int,
    s1: c_int,
    p0: c_int,
    p1: c_int,
    d0: c_int,
    d1: c_int,
    is_2D: bool,
    dst_type: ggml_type
) -> *mut ggml_tensor
{
    ggml_im2col(
        ctx,
        a,
        b,
        s0,
        s1,
        p0,
        p1,
        d0,
        d1,
        is_2D,
        dst_type
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_depthwise_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s0: c_int,
    s1: c_int,
    p0: c_int,
    p1: c_int,
    d0: c_int,
    d1: c_int
) -> *mut ggml_tensor
{
    ggml_conv_depthwise_2d(
        ctx,
        a,
        b,
        s0,
        s1,
        p0,
        p1,
        d0,
        d1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s0: c_int,
    p0: c_int,
    d0: c_int
) -> *mut ggml_tensor
{
    ggml_conv_1d(
        ctx,
        a,
        b,
        s0,
        p0,
        d0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_1d_ph(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s: c_int,
    d: c_int
) -> *mut ggml_tensor
{
    ggml_conv_1d_ph(
        ctx,
        a,
        b,
        s,
        d
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_transpose_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s0: c_int,
    p0: c_int,
    d0: c_int
) -> *mut ggml_tensor
{
    ggml_conv_transpose_1d(
        ctx,
        a,
        b,
        s0,
        p0,
        d0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    s0: c_int,
    s1: c_int,
    p0: c_int,
    p1: c_int,
    d0: c_int,
    d1: c_int
) -> *mut ggml_tensor
{
    ggml_conv_2d(
        ctx,
        a,
        b,
        s0,
        s1,
        p0,
        p1,
        d0,
        d1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_2d_sk_p0(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_conv_2d_sk_p0(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_2d_s1_ph(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_conv_2d_s1_ph(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_conv_transpose_2d_p0(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    stride: c_int
) -> *mut ggml_tensor
{
    ggml_conv_transpose_2d_p0(
        ctx,
        a,
        b,
        stride
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_pool_1d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    op: ggml_op_pool,
    k0: c_int,
    s0: c_int,
    p0: c_int
) -> *mut ggml_tensor
{
    ggml_pool_1d(
        ctx,
        a,
        op,
        k0,
        s0,
        p0
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_pool_2d(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    op: ggml_op_pool,
    k0: c_int,
    k1: c_int,
    s0: c_int,
    s1: c_int,
    p0: f32,
    p1: f32
) -> *mut ggml_tensor
{
    ggml_pool_2d(
        ctx,
        a,
        op,
        k0,
        k1,
        s0,
        s1,
        p0,
        p1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_upscale(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    scale_factor: c_int
) -> *mut ggml_tensor
{
    ggml_upscale(
        ctx,
        a,
        scale_factor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_pad(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    p0: c_int,
    p1: c_int,
    p2: c_int,
    p3: c_int
) -> *mut ggml_tensor
{
    ggml_pad(
        ctx,
        a,
        p0,
        p1,
        p2,
        p3
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_timestep_embedding(
    ctx: *mut ggml_context,
    timesteps: *mut ggml_tensor,
    dim: c_int,
    max_period: c_int
) -> *mut ggml_tensor
{
    ggml_timestep_embedding(
        ctx,
        timesteps,
        dim,
        max_period
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_argsort(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    order: ggml_sort_order
) -> *mut ggml_tensor
{
    ggml_argsort(
        ctx,
        a,
        order
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_arange(
    ctx: *mut ggml_context,
    start: f32,
    stop: f32,
    step: f32
) -> *mut ggml_tensor
{
    ggml_arange(
        ctx,
        start,
        stop,
        step
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_top_k(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    k: c_int
) -> *mut ggml_tensor
{
    ggml_top_k(
        ctx,
        a,
        k
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_flash_attn(
    ctx: *mut ggml_context,
    q: *mut ggml_tensor,
    k: *mut ggml_tensor,
    v: *mut ggml_tensor,
    masked: bool
) -> *mut ggml_tensor
{
    ggml_flash_attn(
        ctx,
        q,
        k,
        v,
        masked
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_flash_attn_back(
    ctx: *mut ggml_context,
    q: *mut ggml_tensor,
    k: *mut ggml_tensor,
    v: *mut ggml_tensor,
    d: *mut ggml_tensor,
    masked: bool
) -> *mut ggml_tensor
{
    ggml_flash_attn_back(
        ctx,
        q,
        k,
        v,
        d,
        masked
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_flash_ff(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b0: *mut ggml_tensor,
    b1: *mut ggml_tensor,
    c0: *mut ggml_tensor,
    c1: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_flash_ff(
        ctx,
        a,
        b0,
        b1,
        c0,
        c1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_ssm_conv(
    ctx: *mut ggml_context,
    s: *mut ggml_tensor,
    x: *mut ggml_tensor,
    c: *mut ggml_tensor,
    sq: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_ssm_conv(
        ctx,
        s,
        x,
        c,
        sq
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_ssm_scan(
    ctx: *mut ggml_context,
    s: *mut ggml_tensor,
    x: *mut ggml_tensor,
    dt: *mut ggml_tensor,
    A: *mut ggml_tensor,
    B: *mut ggml_tensor,
    C: *mut ggml_tensor,
    sq: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_ssm_scan(
        ctx,
        s,
        x,
        dt,
        A,
        B,
        C,
        sq
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_win_part(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    w: c_int
) -> *mut ggml_tensor
{
    ggml_win_part(
        ctx,
        a,
        w
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_win_unpart(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    w0: c_int,
    h0: c_int,
    w: c_int
) -> *mut ggml_tensor
{
    ggml_win_unpart(
        ctx,
        a,
        w0,
        h0,
        w
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_unary(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    op: ggml_unary_op
) -> *mut ggml_tensor
{
    ggml_unary(
        ctx,
        a,
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_unary_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    op: ggml_unary_op
) -> *mut ggml_tensor
{
    ggml_unary_inplace(
        ctx,
        a,
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_get_rel_pos(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    qh: c_int,
    kh: c_int
) -> *mut ggml_tensor
{
    ggml_get_rel_pos(
        ctx,
        a,
        qh,
        kh
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add_rel_pos(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    pw: *mut ggml_tensor,
    ph: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add_rel_pos(
        ctx,
        a,
        pw,
        ph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_add_rel_pos_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    pw: *mut ggml_tensor,
    ph: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_add_rel_pos_inplace(
        ctx,
        a,
        pw,
        ph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_unary_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_unary_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_unary_f32(
        ctx,
        a,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_unary_inplace_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_unary_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_unary_inplace_f32(
        ctx,
        a,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_binary_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_binary_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_binary_f32(
        ctx,
        a,
        b,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_binary_inplace_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_binary_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_binary_inplace_f32(
        ctx,
        a,
        b,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom1_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_custom1_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom1_f32(
        ctx,
        a,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom1_inplace_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_custom1_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom1_inplace_f32(
        ctx,
        a,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom2_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_custom2_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom2_f32(
        ctx,
        a,
        b,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom2_inplace_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_custom2_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom2_inplace_f32(
        ctx,
        a,
        b,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom3_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor,
    fun: ggml_custom3_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom3_f32(
        ctx,
        a,
        b,
        c,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom3_inplace_f32(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor,
    fun: ggml_custom3_op_f32_t
) -> *mut ggml_tensor
{
    ggml_map_custom3_inplace_f32(
        ctx,
        a,
        b,
        c,
        fun
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom1(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_custom1_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom1(
        ctx,
        a,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom1_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    fun: ggml_custom1_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom1_inplace(
        ctx,
        a,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom2(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_custom2_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom2(
        ctx,
        a,
        b,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom2_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    fun: ggml_custom2_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom2_inplace(
        ctx,
        a,
        b,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom3(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor,
    fun: ggml_custom3_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom3(
        ctx,
        a,
        b,
        c,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_map_custom3_inplace(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor,
    fun: ggml_custom3_op_t,
    n_tasks: c_int,
    userdata: *mut c_void
) -> *mut ggml_tensor
{
    ggml_map_custom3_inplace(
        ctx,
        a,
        b,
        c,
        fun,
        n_tasks,
        userdata
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cross_entropy_loss(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_cross_entropy_loss(
        ctx,
        a,
        b
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cross_entropy_loss_back(
    ctx: *mut ggml_context,
    a: *mut ggml_tensor,
    b: *mut ggml_tensor,
    c: *mut ggml_tensor
) -> *mut ggml_tensor
{
    ggml_cross_entropy_loss_back(
        ctx,
        a,
        b,
        c
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_param(
    ctx: *mut ggml_context,
    tensor: *mut ggml_tensor
)
{
    ggml_set_param(
        ctx,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_build_forward_expand(
    cgraph: *mut ggml_cgraph,
    tensor: *mut ggml_tensor
)
{
    ggml_build_forward_expand(
        cgraph,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_build_backward_expand(
    ctx: *mut ggml_context,
    gf: *mut ggml_cgraph,
    gb: *mut ggml_cgraph,
    keep: bool
)
{
    ggml_build_backward_expand(
        ctx,
        gf,
        gb,
        keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_graph(
    ctx: *mut ggml_context
) -> *mut ggml_cgraph
{
    ggml_new_graph(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_new_graph_custom(
    ctx: *mut ggml_context,
    size: usize,
    grads: bool
) -> *mut ggml_cgraph
{
    ggml_new_graph_custom(
        ctx,
        size,
        grads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_dup(
    ctx: *mut ggml_context,
    cgraph: *mut ggml_cgraph
) -> *mut ggml_cgraph
{
    ggml_graph_dup(
        ctx,
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_view(
    cgraph: *mut ggml_cgraph,
    i0: c_int,
    i1: c_int
) -> ggml_cgraph
{
    ggml_graph_view(
        cgraph,
        i0,
        i1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_cpy(
    src: *mut ggml_cgraph,
    dst: *mut ggml_cgraph
)
{
    ggml_graph_cpy(
        src,
        dst
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_reset(
    cgraph: *mut ggml_cgraph
)
{
    ggml_graph_reset(
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_clear(
    cgraph: *mut ggml_cgraph
)
{
    ggml_graph_clear(
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_overhead(

) -> usize
{
    ggml_graph_overhead(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_overhead_custom(
    size: usize,
    grads: bool
) -> usize
{
    ggml_graph_overhead_custom(
        size,
        grads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_plan(
    cgraph: *const ggml_cgraph,
    n_threads: c_int
) -> ggml_cplan
{
    ggml_graph_plan(
        cgraph,
        n_threads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_compute(
    cgraph: *mut ggml_cgraph,
    cplan: *mut ggml_cplan
) -> ggml_status
{
    ggml_graph_compute(
        cgraph,
        cplan
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_compute_with_ctx(
    ctx: *mut ggml_context,
    cgraph: *mut ggml_cgraph,
    n_threads: c_int
) -> ggml_status
{
    ggml_graph_compute_with_ctx(
        ctx,
        cgraph,
        n_threads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_get_tensor(
    cgraph: *mut ggml_cgraph,
    name: *const c_char
) -> *mut ggml_tensor
{
    ggml_graph_get_tensor(
        cgraph,
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_export(
    cgraph: *const ggml_cgraph,
    fname: *const c_char
)
{
    ggml_graph_export(
        cgraph,
        fname
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_import(
    fname: *const c_char,
    ctx_data: *mut *mut ggml_context,
    ctx_eval: *mut *mut ggml_context
) -> *mut ggml_cgraph
{
    ggml_graph_import(
        fname,
        ctx_data,
        ctx_eval
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_print(
    cgraph: *const ggml_cgraph
)
{
    ggml_graph_print(
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_graph_dump_dot(
    gb: *const ggml_cgraph,
    gf: *const ggml_cgraph,
    filename: *const c_char
)
{
    ggml_graph_dump_dot(
        gb,
        gf,
        filename
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_build_backward_gradient_checkpointing(
    ctx: *mut ggml_context,
    gf: *mut ggml_cgraph,
    gb: *mut ggml_cgraph,
    gb_tmp: *mut ggml_cgraph,
    checkpoints: *mut *mut ggml_tensor,
    n_checkpoints: c_int
)
{
    ggml_build_backward_gradient_checkpointing(
        ctx,
        gf,
        gb,
        gb_tmp,
        checkpoints,
        n_checkpoints
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_opt_default_params(
    type_: ggml_opt_type
) -> ggml_opt_params
{
    ggml_opt_default_params(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_opt(
    ctx: *mut ggml_context,
    params: ggml_opt_params,
    f: *mut ggml_tensor
) -> ggml_opt_result
{
    ggml_opt(
        ctx,
        params,
        f
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_opt_init(
    ctx: *mut ggml_context,
    opt: *mut ggml_opt_context,
    params: ggml_opt_params,
    nx: i64
)
{
    ggml_opt_init(
        ctx,
        opt,
        params,
        nx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_opt_resume(
    ctx: *mut ggml_context,
    opt: *mut ggml_opt_context,
    f: *mut ggml_tensor
) -> ggml_opt_result
{
    ggml_opt_resume(
        ctx,
        opt,
        f
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_opt_resume_g(
    ctx: *mut ggml_context,
    opt: *mut ggml_opt_context,
    f: *mut ggml_tensor,
    gf: *mut ggml_cgraph,
    gb: *mut ggml_cgraph,
    callback: ggml_opt_callback,
    callback_data: *mut c_void
) -> ggml_opt_result
{
    ggml_opt_resume_g(
        ctx,
        opt,
        f,
        gf,
        gb,
        callback,
        callback_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_input(
    tensor: *mut ggml_tensor
)
{
    ggml_set_input(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_set_output(
    tensor: *mut ggml_tensor
)
{
    ggml_set_output(
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_quantize_init(
    type_: ggml_type
)
{
    ggml_quantize_init(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_quantize_free(

)
{
    ggml_quantize_free(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_quantize_requires_imatrix(
    type_: ggml_type
) -> bool
{
    ggml_quantize_requires_imatrix(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_quantize_chunk(
    type_: ggml_type,
    src: *const f32,
    dst: *mut c_void,
    start: c_int,
    nrows: c_int,
    n_per_row: c_int,
    imatrix: *const f32
) -> usize
{
    ggml_quantize_chunk(
        type_,
        src,
        dst,
        start,
        nrows,
        n_per_row,
        imatrix
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_init_empty(

) -> *mut gguf_context
{
    gguf_init_empty(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_init_from_file(
    fname: *const c_char,
    params: gguf_init_params
) -> *mut gguf_context
{
    gguf_init_from_file(
        fname,
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_free(
    ctx: *mut gguf_context
)
{
    gguf_free(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_type_name(
    type_: gguf_type
) -> *const c_char
{
    gguf_type_name(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_version(
    ctx: *const gguf_context
) -> c_int
{
    gguf_get_version(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_alignment(
    ctx: *const gguf_context
) -> usize
{
    gguf_get_alignment(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_data_offset(
    ctx: *const gguf_context
) -> usize
{
    gguf_get_data_offset(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_data(
    ctx: *const gguf_context
) -> *mut c_void
{
    gguf_get_data(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_n_kv(
    ctx: *const gguf_context
) -> c_int
{
    gguf_get_n_kv(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_find_key(
    ctx: *const gguf_context,
    key: *const c_char
) -> c_int
{
    gguf_find_key(
        ctx,
        key
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_key(
    ctx: *const gguf_context,
    key_id: c_int
) -> *const c_char
{
    gguf_get_key(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_kv_type(
    ctx: *const gguf_context,
    key_id: c_int
) -> gguf_type
{
    gguf_get_kv_type(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_arr_type(
    ctx: *const gguf_context,
    key_id: c_int
) -> gguf_type
{
    gguf_get_arr_type(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_u8(
    ctx: *const gguf_context,
    key_id: c_int
) -> u8
{
    gguf_get_val_u8(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_i8(
    ctx: *const gguf_context,
    key_id: c_int
) -> i8
{
    gguf_get_val_i8(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_u16(
    ctx: *const gguf_context,
    key_id: c_int
) -> u16
{
    gguf_get_val_u16(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_i16(
    ctx: *const gguf_context,
    key_id: c_int
) -> i16
{
    gguf_get_val_i16(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_u32(
    ctx: *const gguf_context,
    key_id: c_int
) -> u32
{
    gguf_get_val_u32(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_i32(
    ctx: *const gguf_context,
    key_id: c_int
) -> i32
{
    gguf_get_val_i32(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_f32(
    ctx: *const gguf_context,
    key_id: c_int
) -> f32
{
    gguf_get_val_f32(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_u64(
    ctx: *const gguf_context,
    key_id: c_int
) -> u64
{
    gguf_get_val_u64(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_i64(
    ctx: *const gguf_context,
    key_id: c_int
) -> i64
{
    gguf_get_val_i64(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_f64(
    ctx: *const gguf_context,
    key_id: c_int
) -> f64
{
    gguf_get_val_f64(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_bool(
    ctx: *const gguf_context,
    key_id: c_int
) -> bool
{
    gguf_get_val_bool(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_str(
    ctx: *const gguf_context,
    key_id: c_int
) -> *const c_char
{
    gguf_get_val_str(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_val_data(
    ctx: *const gguf_context,
    key_id: c_int
) -> *const c_void
{
    gguf_get_val_data(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_arr_n(
    ctx: *const gguf_context,
    key_id: c_int
) -> c_int
{
    gguf_get_arr_n(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_arr_data(
    ctx: *const gguf_context,
    key_id: c_int
) -> *const c_void
{
    gguf_get_arr_data(
        ctx,
        key_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_arr_str(
    ctx: *const gguf_context,
    key_id: c_int,
    i: c_int
) -> *const c_char
{
    gguf_get_arr_str(
        ctx,
        key_id,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_n_tensors(
    ctx: *const gguf_context
) -> c_int
{
    gguf_get_n_tensors(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_find_tensor(
    ctx: *const gguf_context,
    name: *const c_char
) -> c_int
{
    gguf_find_tensor(
        ctx,
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_tensor_offset(
    ctx: *const gguf_context,
    i: c_int
) -> usize
{
    gguf_get_tensor_offset(
        ctx,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_tensor_name(
    ctx: *const gguf_context,
    i: c_int
) -> *mut c_char
{
    gguf_get_tensor_name(
        ctx,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_tensor_type(
    ctx: *const gguf_context,
    i: c_int
) -> ggml_type
{
    gguf_get_tensor_type(
        ctx,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_u8(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: u8
)
{
    gguf_set_val_u8(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_i8(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: i8
)
{
    gguf_set_val_i8(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_u16(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: u16
)
{
    gguf_set_val_u16(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_i16(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: i16
)
{
    gguf_set_val_i16(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_u32(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: u32
)
{
    gguf_set_val_u32(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_i32(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: i32
)
{
    gguf_set_val_i32(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_f32(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: f32
)
{
    gguf_set_val_f32(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_u64(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: u64
)
{
    gguf_set_val_u64(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_i64(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: i64
)
{
    gguf_set_val_i64(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_f64(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: f64
)
{
    gguf_set_val_f64(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_bool(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: bool
)
{
    gguf_set_val_bool(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_val_str(
    ctx: *mut gguf_context,
    key: *const c_char,
    val: *const c_char
)
{
    gguf_set_val_str(
        ctx,
        key,
        val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_arr_data(
    ctx: *mut gguf_context,
    key: *const c_char,
    type_: gguf_type,
    data: *const c_void,
    n: c_int
)
{
    gguf_set_arr_data(
        ctx,
        key,
        type_,
        data,
        n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_arr_str(
    ctx: *mut gguf_context,
    key: *const c_char,
    data: *mut *const c_char,
    n: c_int
)
{
    gguf_set_arr_str(
        ctx,
        key,
        data,
        n
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_kv(
    ctx: *mut gguf_context,
    src: *mut gguf_context
)
{
    gguf_set_kv(
        ctx,
        src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_add_tensor(
    ctx: *mut gguf_context,
    tensor: *const ggml_tensor
)
{
    gguf_add_tensor(
        ctx,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_tensor_type(
    ctx: *mut gguf_context,
    name: *const c_char,
    type_: ggml_type
)
{
    gguf_set_tensor_type(
        ctx,
        name,
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_set_tensor_data(
    ctx: *mut gguf_context,
    name: *const c_char,
    data: *const c_void,
    size: usize
)
{
    gguf_set_tensor_data(
        ctx,
        name,
        data,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_write_to_file(
    ctx: *const gguf_context,
    fname: *const c_char,
    only_meta: bool
)
{
    gguf_write_to_file(
        ctx,
        fname,
        only_meta
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_meta_size(
    ctx: *const gguf_context
) -> usize
{
    gguf_get_meta_size(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_gguf_get_meta_data(
    ctx: *const gguf_context,
    data: *mut c_void
)
{
    gguf_get_meta_data(
        ctx,
        data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx(

) -> c_int
{
    ggml_cpu_has_avx(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx_vnni(

) -> c_int
{
    ggml_cpu_has_avx_vnni(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx2(

) -> c_int
{
    ggml_cpu_has_avx2(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx512(

) -> c_int
{
    ggml_cpu_has_avx512(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx512_vbmi(

) -> c_int
{
    ggml_cpu_has_avx512_vbmi(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_avx512_vnni(

) -> c_int
{
    ggml_cpu_has_avx512_vnni(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_fma(

) -> c_int
{
    ggml_cpu_has_fma(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_neon(

) -> c_int
{
    ggml_cpu_has_neon(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_arm_fma(

) -> c_int
{
    ggml_cpu_has_arm_fma(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_metal(

) -> c_int
{
    ggml_cpu_has_metal(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_f16c(

) -> c_int
{
    ggml_cpu_has_f16c(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_fp16_va(

) -> c_int
{
    ggml_cpu_has_fp16_va(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_wasm_simd(

) -> c_int
{
    ggml_cpu_has_wasm_simd(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_blas(

) -> c_int
{
    ggml_cpu_has_blas(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_cuda(

) -> c_int
{
    ggml_cpu_has_cuda(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_clblast(

) -> c_int
{
    ggml_cpu_has_clblast(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_vulkan(

) -> c_int
{
    ggml_cpu_has_vulkan(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_kompute(

) -> c_int
{
    ggml_cpu_has_kompute(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_gpublas(

) -> c_int
{
    ggml_cpu_has_gpublas(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_sse3(

) -> c_int
{
    ggml_cpu_has_sse3(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_ssse3(

) -> c_int
{
    ggml_cpu_has_ssse3(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_sycl(

) -> c_int
{
    ggml_cpu_has_sycl(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_vsx(

) -> c_int
{
    ggml_cpu_has_vsx(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_cpu_has_matmul_int8(

) -> c_int
{
    ggml_cpu_has_matmul_int8(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_internal_get_type_traits(
    type_: ggml_type
) -> ggml_type_traits_t
{
    ggml_internal_get_type_traits(
        type_
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_tallocr_new(
    buffer: ggml_backend_buffer_t
) -> ggml_tallocr
{
    ggml_tallocr_new(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_tallocr_alloc(
    talloc: *mut ggml_tallocr,
    tensor: *mut ggml_tensor
)
{
    ggml_tallocr_alloc(
        talloc,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_new(
    buft: ggml_backend_buffer_type_t
) -> ggml_gallocr_t
{
    ggml_gallocr_new(
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_new_n(
    bufts: *mut ggml_backend_buffer_type_t,
    n_bufs: c_int
) -> ggml_gallocr_t
{
    ggml_gallocr_new_n(
        bufts,
        n_bufs
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_free(
    galloc: ggml_gallocr_t
)
{
    ggml_gallocr_free(
        galloc
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_reserve(
    galloc: ggml_gallocr_t,
    graph: *mut ggml_cgraph
) -> bool
{
    ggml_gallocr_reserve(
        galloc,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_reserve_n(
    galloc: ggml_gallocr_t,
    graph: *mut ggml_cgraph,
    node_buffer_ids: *const c_int,
    leaf_buffer_ids: *const c_int
) -> bool
{
    ggml_gallocr_reserve_n(
        galloc,
        graph,
        node_buffer_ids,
        leaf_buffer_ids
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_alloc_graph(
    galloc: ggml_gallocr_t,
    graph: *mut ggml_cgraph
) -> bool
{
    ggml_gallocr_alloc_graph(
        galloc,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_gallocr_get_buffer_size(
    galloc: ggml_gallocr_t,
    buffer_id: c_int
) -> usize
{
    ggml_gallocr_get_buffer_size(
        galloc,
        buffer_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_alloc_ctx_tensors_from_buft(
    ctx: *mut ggml_context,
    buft: ggml_backend_buffer_type_t
) -> *mut ggml_backend_buffer
{
    ggml_backend_alloc_ctx_tensors_from_buft(
        ctx,
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_alloc_ctx_tensors(
    ctx: *mut ggml_context,
    backend: ggml_backend_t
) -> *mut ggml_backend_buffer
{
    ggml_backend_alloc_ctx_tensors(
        ctx,
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_name(
    buft: ggml_backend_buffer_type_t
) -> *const c_char
{
    ggml_backend_buft_name(
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_alloc_buffer(
    buft: ggml_backend_buffer_type_t,
    size: usize
) -> ggml_backend_buffer_t
{
    ggml_backend_buft_alloc_buffer(
        buft,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_get_alignment(
    buft: ggml_backend_buffer_type_t
) -> usize
{
    ggml_backend_buft_get_alignment(
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_get_max_size(
    buft: ggml_backend_buffer_type_t
) -> usize
{
    ggml_backend_buft_get_max_size(
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_get_alloc_size(
    buft: ggml_backend_buffer_type_t,
    tensor: *mut ggml_tensor
) -> usize
{
    ggml_backend_buft_get_alloc_size(
        buft,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_supports_backend(
    buft: ggml_backend_buffer_type_t,
    backend: ggml_backend_t
) -> bool
{
    ggml_backend_buft_supports_backend(
        buft,
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buft_is_host(
    buft: ggml_backend_buffer_type_t
) -> bool
{
    ggml_backend_buft_is_host(
        buft
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_name(
    buffer: ggml_backend_buffer_t
) -> *const c_char
{
    ggml_backend_buffer_name(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_free(
    buffer: ggml_backend_buffer_t
)
{
    ggml_backend_buffer_free(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_base(
    buffer: ggml_backend_buffer_t
) -> *mut c_void
{
    ggml_backend_buffer_get_base(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_size(
    buffer: ggml_backend_buffer_t
) -> usize
{
    ggml_backend_buffer_get_size(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_init_tensor(
    buffer: ggml_backend_buffer_t,
    tensor: *mut ggml_tensor
)
{
    ggml_backend_buffer_init_tensor(
        buffer,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_alignment(
    buffer: ggml_backend_buffer_t
) -> usize
{
    ggml_backend_buffer_get_alignment(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_max_size(
    buffer: ggml_backend_buffer_t
) -> usize
{
    ggml_backend_buffer_get_max_size(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_alloc_size(
    buffer: ggml_backend_buffer_t,
    tensor: *mut ggml_tensor
) -> usize
{
    ggml_backend_buffer_get_alloc_size(
        buffer,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_clear(
    buffer: ggml_backend_buffer_t,
    value: u8
)
{
    ggml_backend_buffer_clear(
        buffer,
        value
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_is_host(
    buffer: ggml_backend_buffer_t
) -> bool
{
    ggml_backend_buffer_is_host(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_set_usage(
    buffer: ggml_backend_buffer_t,
    usage: ggml_backend_buffer_usage
)
{
    ggml_backend_buffer_set_usage(
        buffer,
        usage
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_get_type(
    buffer: ggml_backend_buffer_t
) -> ggml_backend_buffer_type_t
{
    ggml_backend_buffer_get_type(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_buffer_reset(
    buffer: ggml_backend_buffer_t
)
{
    ggml_backend_buffer_reset(
        buffer
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_guid(
    backend: ggml_backend_t
) -> ggml_guid_t
{
    ggml_backend_guid(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_name(
    backend: ggml_backend_t
) -> *const c_char
{
    ggml_backend_name(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_free(
    backend: ggml_backend_t
)
{
    ggml_backend_free(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_get_default_buffer_type(
    backend: ggml_backend_t
) -> ggml_backend_buffer_type_t
{
    ggml_backend_get_default_buffer_type(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_alloc_buffer(
    backend: ggml_backend_t,
    size: usize
) -> ggml_backend_buffer_t
{
    ggml_backend_alloc_buffer(
        backend,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_get_alignment(
    backend: ggml_backend_t
) -> usize
{
    ggml_backend_get_alignment(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_get_max_size(
    backend: ggml_backend_t
) -> usize
{
    ggml_backend_get_max_size(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_set_async(
    backend: ggml_backend_t,
    tensor: *mut ggml_tensor,
    data: *const c_void,
    offset: usize,
    size: usize
)
{
    ggml_backend_tensor_set_async(
        backend,
        tensor,
        data,
        offset,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_get_async(
    backend: ggml_backend_t,
    tensor: *const ggml_tensor,
    data: *mut c_void,
    offset: usize,
    size: usize
)
{
    ggml_backend_tensor_get_async(
        backend,
        tensor,
        data,
        offset,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_set(
    tensor: *mut ggml_tensor,
    data: *const c_void,
    offset: usize,
    size: usize
)
{
    ggml_backend_tensor_set(
        tensor,
        data,
        offset,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_get(
    tensor: *const ggml_tensor,
    data: *mut c_void,
    offset: usize,
    size: usize
)
{
    ggml_backend_tensor_get(
        tensor,
        data,
        offset,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_synchronize(
    backend: ggml_backend_t
)
{
    ggml_backend_synchronize(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_plan_create(
    backend: ggml_backend_t,
    cgraph: *mut ggml_cgraph
) -> ggml_backend_graph_plan_t
{
    ggml_backend_graph_plan_create(
        backend,
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_plan_free(
    backend: ggml_backend_t,
    plan: ggml_backend_graph_plan_t
)
{
    ggml_backend_graph_plan_free(
        backend,
        plan
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_plan_compute(
    backend: ggml_backend_t,
    plan: ggml_backend_graph_plan_t
) -> ggml_status
{
    ggml_backend_graph_plan_compute(
        backend,
        plan
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_compute(
    backend: ggml_backend_t,
    cgraph: *mut ggml_cgraph
) -> ggml_status
{
    ggml_backend_graph_compute(
        backend,
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_compute_async(
    backend: ggml_backend_t,
    cgraph: *mut ggml_cgraph
) -> ggml_status
{
    ggml_backend_graph_compute_async(
        backend,
        cgraph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_supports_op(
    backend: ggml_backend_t,
    op: *const ggml_tensor
) -> bool
{
    ggml_backend_supports_op(
        backend,
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_offload_op(
    backend: ggml_backend_t,
    op: *const ggml_tensor
) -> bool
{
    ggml_backend_offload_op(
        backend,
        op
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_copy(
    src: *mut ggml_tensor,
    dst: *mut ggml_tensor
)
{
    ggml_backend_tensor_copy(
        src,
        dst
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_copy_async(
    backend_src: ggml_backend_t,
    backend_dst: ggml_backend_t,
    src: *mut ggml_tensor,
    dst: *mut ggml_tensor
)
{
    ggml_backend_tensor_copy_async(
        backend_src,
        backend_dst,
        src,
        dst
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_event_new(
    backend: ggml_backend_t
) -> ggml_backend_event_t
{
    ggml_backend_event_new(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_event_free(
    event: ggml_backend_event_t
)
{
    ggml_backend_event_free(
        event
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_event_record(
    event: ggml_backend_event_t
)
{
    ggml_backend_event_record(
        event
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_event_synchronize(
    event: ggml_backend_event_t
)
{
    ggml_backend_event_synchronize(
        event
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_event_wait(
    backend: ggml_backend_t,
    event: ggml_backend_event_t
)
{
    ggml_backend_event_wait(
        backend,
        event
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_cpu_init(

) -> ggml_backend_t
{
    ggml_backend_cpu_init(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_is_cpu(
    backend: ggml_backend_t
) -> bool
{
    ggml_backend_is_cpu(
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_cpu_set_n_threads(
    backend_cpu: ggml_backend_t,
    n_threads: c_int
)
{
    ggml_backend_cpu_set_n_threads(
        backend_cpu,
        n_threads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_cpu_set_abort_callback(
    backend_cpu: ggml_backend_t,
    abort_callback: ggml_abort_callback,
    abort_callback_data: *mut c_void
)
{
    ggml_backend_cpu_set_abort_callback(
        backend_cpu,
        abort_callback,
        abort_callback_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_cpu_buffer_from_ptr(
    ptr: *mut c_void,
    size: usize
) -> ggml_backend_buffer_t
{
    ggml_backend_cpu_buffer_from_ptr(
        ptr,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_cpu_buffer_type(

) -> ggml_backend_buffer_type_t
{
    ggml_backend_cpu_buffer_type(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_get_count(

) -> usize
{
    ggml_backend_reg_get_count(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_find_by_name(
    name: *const c_char
) -> usize
{
    ggml_backend_reg_find_by_name(
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_init_backend_from_str(
    backend_str: *const c_char
) -> ggml_backend_t
{
    ggml_backend_reg_init_backend_from_str(
        backend_str
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_get_name(
    i: usize
) -> *const c_char
{
    ggml_backend_reg_get_name(
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_init_backend(
    i: usize,
    params: *const c_char
) -> ggml_backend_t
{
    ggml_backend_reg_init_backend(
        i,
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_get_default_buffer_type(
    i: usize
) -> ggml_backend_buffer_type_t
{
    ggml_backend_reg_get_default_buffer_type(
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_reg_alloc_buffer(
    i: usize,
    size: usize
) -> ggml_backend_buffer_t
{
    ggml_backend_reg_alloc_buffer(
        i,
        size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_new(
    backends: *mut ggml_backend_t,
    bufts: *mut ggml_backend_buffer_type_t,
    n_backends: c_int,
    graph_size: usize,
    parallel: bool
) -> ggml_backend_sched_t
{
    ggml_backend_sched_new(
        backends,
        bufts,
        n_backends,
        graph_size,
        parallel
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_free(
    sched: ggml_backend_sched_t
)
{
    ggml_backend_sched_free(
        sched
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_reserve(
    sched: ggml_backend_sched_t,
    measure_graph: *mut ggml_cgraph
) -> bool
{
    ggml_backend_sched_reserve(
        sched,
        measure_graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_get_n_splits(
    sched: ggml_backend_sched_t
) -> c_int
{
    ggml_backend_sched_get_n_splits(
        sched
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_get_n_copies(
    sched: ggml_backend_sched_t
) -> c_int
{
    ggml_backend_sched_get_n_copies(
        sched
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_get_buffer_size(
    sched: ggml_backend_sched_t,
    backend: ggml_backend_t
) -> usize
{
    ggml_backend_sched_get_buffer_size(
        sched,
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_set_tensor_backend(
    sched: ggml_backend_sched_t,
    node: *mut ggml_tensor,
    backend: ggml_backend_t
)
{
    ggml_backend_sched_set_tensor_backend(
        sched,
        node,
        backend
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_get_tensor_backend(
    sched: ggml_backend_sched_t,
    node: *mut ggml_tensor
) -> ggml_backend_t
{
    ggml_backend_sched_get_tensor_backend(
        sched,
        node
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_alloc_graph(
    sched: ggml_backend_sched_t,
    graph: *mut ggml_cgraph
) -> bool
{
    ggml_backend_sched_alloc_graph(
        sched,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_graph_compute(
    sched: ggml_backend_sched_t,
    graph: *mut ggml_cgraph
) -> ggml_status
{
    ggml_backend_sched_graph_compute(
        sched,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_graph_compute_async(
    sched: ggml_backend_sched_t,
    graph: *mut ggml_cgraph
) -> ggml_status
{
    ggml_backend_sched_graph_compute_async(
        sched,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_synchronize(
    sched: ggml_backend_sched_t
)
{
    ggml_backend_sched_synchronize(
        sched
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_reset(
    sched: ggml_backend_sched_t
)
{
    ggml_backend_sched_reset(
        sched
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_sched_set_eval_callback(
    sched: ggml_backend_sched_t,
    callback: ggml_backend_sched_eval_callback,
    user_data: *mut c_void
)
{
    ggml_backend_sched_set_eval_callback(
        sched,
        callback,
        user_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_copy(
    backend: ggml_backend_t,
    graph: *mut ggml_cgraph
) -> ggml_backend_graph_copy
{
    ggml_backend_graph_copy(
        backend,
        graph
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_graph_copy_free(
    copy: ggml_backend_graph_copy
)
{
    ggml_backend_graph_copy_free(
        copy
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_compare_graph_backend(
    backend1: ggml_backend_t,
    backend2: ggml_backend_t,
    graph: *mut ggml_cgraph,
    callback: ggml_backend_eval_callback,
    user_data: *mut c_void
) -> bool
{
    ggml_backend_compare_graph_backend(
        backend1,
        backend2,
        graph,
        callback,
        user_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_tensor_alloc(
    buffer: ggml_backend_buffer_t,
    tensor: *mut ggml_tensor,
    addr: *mut c_void
)
{
    ggml_backend_tensor_alloc(
        buffer,
        tensor,
        addr
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_ggml_backend_view_init(
    buffer: ggml_backend_buffer_t,
    tensor: *mut ggml_tensor
)
{
    ggml_backend_view_init(
        buffer,
        tensor
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_default_params(

) -> llama_model_params
{
    llama_model_default_params(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_context_default_params(

) -> llama_context_params
{
    llama_context_default_params(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_quantize_default_params(

) -> llama_model_quantize_params
{
    llama_model_quantize_default_params(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_backend_init(

)
{
    llama_backend_init(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_numa_init(
    numa: ggml_numa_strategy
)
{
    llama_numa_init(
        numa
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_backend_free(

)
{
    llama_backend_free(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_load_model_from_file(
    path_model: *const c_char,
    params: llama_model_params
) -> *mut llama_model
{
    llama_load_model_from_file(
        path_model,
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_free_model(
    model: *mut llama_model
)
{
    llama_free_model(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_new_context_with_model(
    model: *mut llama_model,
    params: llama_context_params
) -> *mut llama_context
{
    llama_new_context_with_model(
        model,
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_free(
    ctx: *mut llama_context
)
{
    llama_free(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_time_us(

) -> i64
{
    llama_time_us(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_max_devices(

) -> usize
{
    llama_max_devices(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_supports_mmap(

) -> bool
{
    llama_supports_mmap(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_supports_mlock(

) -> bool
{
    llama_supports_mlock(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_supports_gpu_offload(

) -> bool
{
    llama_supports_gpu_offload(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_model(
    ctx: *const llama_context
) -> *const llama_model
{
    llama_get_model(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_ctx(
    ctx: *const llama_context
) -> u32
{
    llama_n_ctx(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_batch(
    ctx: *const llama_context
) -> u32
{
    llama_n_batch(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_ubatch(
    ctx: *const llama_context
) -> u32
{
    llama_n_ubatch(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_seq_max(
    ctx: *const llama_context
) -> u32
{
    llama_n_seq_max(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_vocab_type(
    model: *const llama_model
) -> llama_vocab_type
{
    llama_vocab_type(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_rope_type(
    model: *const llama_model
) -> llama_rope_type
{
    llama_rope_type(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_vocab(
    model: *const llama_model
) -> i32
{
    llama_n_vocab(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_ctx_train(
    model: *const llama_model
) -> i32
{
    llama_n_ctx_train(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_embd(
    model: *const llama_model
) -> i32
{
    llama_n_embd(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_n_layer(
    model: *const llama_model
) -> i32
{
    llama_n_layer(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_rope_freq_scale_train(
    model: *const llama_model
) -> f32
{
    llama_rope_freq_scale_train(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_meta_val_str(
    model: *const llama_model,
    key: *const c_char,
    buf: *mut c_char,
    buf_size: usize
) -> i32
{
    llama_model_meta_val_str(
        model,
        key,
        buf,
        buf_size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_meta_count(
    model: *const llama_model
) -> i32
{
    llama_model_meta_count(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_meta_key_by_index(
    model: *const llama_model,
    i: i32,
    buf: *mut c_char,
    buf_size: usize
) -> i32
{
    llama_model_meta_key_by_index(
        model,
        i,
        buf,
        buf_size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_meta_val_str_by_index(
    model: *const llama_model,
    i: i32,
    buf: *mut c_char,
    buf_size: usize
) -> i32
{
    llama_model_meta_val_str_by_index(
        model,
        i,
        buf,
        buf_size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_desc(
    model: *const llama_model,
    buf: *mut c_char,
    buf_size: usize
) -> i32
{
    llama_model_desc(
        model,
        buf,
        buf_size
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_size(
    model: *const llama_model
) -> u64
{
    llama_model_size(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_n_params(
    model: *const llama_model
) -> u64
{
    llama_model_n_params(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_model_tensor(
    model: *mut llama_model,
    name: *const c_char
) -> *mut ggml_tensor
{
    llama_get_model_tensor(
        model,
        name
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_quantize(
    fname_inp: *const c_char,
    fname_out: *const c_char,
    params: *const llama_model_quantize_params
) -> u32
{
    llama_model_quantize(
        fname_inp,
        fname_out,
        params
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_model_apply_lora_from_file(
    model: *const llama_model,
    path_lora: *const c_char,
    scale: f32,
    path_base_model: *const c_char,
    n_threads: i32
) -> i32
{
    llama_model_apply_lora_from_file(
        model,
        path_lora,
        scale,
        path_base_model,
        n_threads
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_control_vector_apply(
    lctx: *mut llama_context,
    data: *const f32,
    len: usize,
    n_embd: i32,
    il_start: i32,
    il_end: i32
) -> i32
{
    llama_control_vector_apply(
        lctx,
        data,
        len,
        n_embd,
        il_start,
        il_end
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_view_init(
    ctx: *const llama_context,
    n_seq_max: i32
) -> llama_kv_cache_view
{
    llama_kv_cache_view_init(
        ctx,
        n_seq_max
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_view_free(
    view: *mut llama_kv_cache_view
)
{
    llama_kv_cache_view_free(
        view
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_view_update(
    ctx: *const llama_context,
    view: *mut llama_kv_cache_view
)
{
    llama_kv_cache_view_update(
        ctx,
        view
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_kv_cache_token_count(
    ctx: *const llama_context
) -> i32
{
    llama_get_kv_cache_token_count(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_kv_cache_used_cells(
    ctx: *const llama_context
) -> i32
{
    llama_get_kv_cache_used_cells(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_clear(
    ctx: *mut llama_context
)
{
    llama_kv_cache_clear(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_rm(
    ctx: *mut llama_context,
    seq_id: llama_seq_id,
    p0: llama_pos,
    p1: llama_pos
) -> bool
{
    llama_kv_cache_seq_rm(
        ctx,
        seq_id,
        p0,
        p1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_cp(
    ctx: *mut llama_context,
    seq_id_src: llama_seq_id,
    seq_id_dst: llama_seq_id,
    p0: llama_pos,
    p1: llama_pos
)
{
    llama_kv_cache_seq_cp(
        ctx,
        seq_id_src,
        seq_id_dst,
        p0,
        p1
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_keep(
    ctx: *mut llama_context,
    seq_id: llama_seq_id
)
{
    llama_kv_cache_seq_keep(
        ctx,
        seq_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_add(
    ctx: *mut llama_context,
    seq_id: llama_seq_id,
    p0: llama_pos,
    p1: llama_pos,
    delta: llama_pos
)
{
    llama_kv_cache_seq_add(
        ctx,
        seq_id,
        p0,
        p1,
        delta
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_div(
    ctx: *mut llama_context,
    seq_id: llama_seq_id,
    p0: llama_pos,
    p1: llama_pos,
    d: c_int
)
{
    llama_kv_cache_seq_div(
        ctx,
        seq_id,
        p0,
        p1,
        d
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_seq_pos_max(
    ctx: *mut llama_context,
    seq_id: llama_seq_id
) -> llama_pos
{
    llama_kv_cache_seq_pos_max(
        ctx,
        seq_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_defrag(
    ctx: *mut llama_context
)
{
    llama_kv_cache_defrag(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_kv_cache_update(
    ctx: *mut llama_context
)
{
    llama_kv_cache_update(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_state_size(
    ctx: *const llama_context
) -> usize
{
    llama_get_state_size(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_copy_state_data(
    ctx: *mut llama_context,
    dst: *mut u8
) -> usize
{
    llama_copy_state_data(
        ctx,
        dst
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_set_state_data(
    ctx: *mut llama_context,
    src: *const u8
) -> usize
{
    llama_set_state_data(
        ctx,
        src
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_load_session_file(
    ctx: *mut llama_context,
    path_session: *const c_char,
    tokens_out: *mut llama_token,
    n_token_capacity: usize,
    n_token_count_out: *mut usize
) -> bool
{
    llama_load_session_file(
        ctx,
        path_session,
        tokens_out,
        n_token_capacity,
        n_token_count_out
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_save_session_file(
    ctx: *mut llama_context,
    path_session: *const c_char,
    tokens: *const llama_token,
    n_token_count: usize
) -> bool
{
    llama_save_session_file(
        ctx,
        path_session,
        tokens,
        n_token_count
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_batch_get_one(
    tokens: *mut llama_token,
    n_tokens: i32,
    pos_0: llama_pos,
    seq_id: llama_seq_id
) -> llama_batch
{
    llama_batch_get_one(
        tokens,
        n_tokens,
        pos_0,
        seq_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_batch_init(
    n_tokens: i32,
    embd: i32,
    n_seq_max: i32
) -> llama_batch
{
    llama_batch_init(
        n_tokens,
        embd,
        n_seq_max
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_batch_free(
    batch: llama_batch
)
{
    llama_batch_free(
        batch
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_decode(
    ctx: *mut llama_context,
    batch: llama_batch
) -> i32
{
    llama_decode(
        ctx,
        batch
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_set_n_threads(
    ctx: *mut llama_context,
    n_threads: u32,
    n_threads_batch: u32
)
{
    llama_set_n_threads(
        ctx,
        n_threads,
        n_threads_batch
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_set_causal_attn(
    ctx: *mut llama_context,
    causal_attn: bool
)
{
    llama_set_causal_attn(
        ctx,
        causal_attn
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_set_abort_callback(
    ctx: *mut llama_context,
    abort_callback: ggml_abort_callback,
    abort_callback_data: *mut c_void
)
{
    llama_set_abort_callback(
        ctx,
        abort_callback,
        abort_callback_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_synchronize(
    ctx: *mut llama_context
)
{
    llama_synchronize(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_logits(
    ctx: *mut llama_context
) -> *mut f32
{
    llama_get_logits(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_logits_ith(
    ctx: *mut llama_context,
    i: i32
) -> *mut f32
{
    llama_get_logits_ith(
        ctx,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_embeddings(
    ctx: *mut llama_context
) -> *mut f32
{
    llama_get_embeddings(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_embeddings_ith(
    ctx: *mut llama_context,
    i: i32
) -> *mut f32
{
    llama_get_embeddings_ith(
        ctx,
        i
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_embeddings_seq(
    ctx: *mut llama_context,
    seq_id: llama_seq_id
) -> *mut f32
{
    llama_get_embeddings_seq(
        ctx,
        seq_id
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_get_text(
    model: *const llama_model,
    token: llama_token
) -> *const c_char
{
    llama_token_get_text(
        model,
        token
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_get_score(
    model: *const llama_model,
    token: llama_token
) -> f32
{
    llama_token_get_score(
        model,
        token
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_get_type(
    model: *const llama_model,
    token: llama_token
) -> llama_token_type
{
    llama_token_get_type(
        model,
        token
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_bos(
    model: *const llama_model
) -> llama_token
{
    llama_token_bos(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_eos(
    model: *const llama_model
) -> llama_token
{
    llama_token_eos(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_nl(
    model: *const llama_model
) -> llama_token
{
    llama_token_nl(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_add_bos_token(
    model: *const llama_model
) -> i32
{
    llama_add_bos_token(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_add_eos_token(
    model: *const llama_model
) -> i32
{
    llama_add_eos_token(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_prefix(
    model: *const llama_model
) -> llama_token
{
    llama_token_prefix(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_middle(
    model: *const llama_model
) -> llama_token
{
    llama_token_middle(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_suffix(
    model: *const llama_model
) -> llama_token
{
    llama_token_suffix(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_eot(
    model: *const llama_model
) -> llama_token
{
    llama_token_eot(
        model
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_tokenize(
    model: *const llama_model,
    text: *const c_char,
    text_len: i32,
    tokens: *mut llama_token,
    n_tokens_max: i32,
    add_bos: bool,
    special: bool
) -> i32
{
    llama_tokenize(
        model,
        text,
        text_len,
        tokens,
        n_tokens_max,
        add_bos,
        special
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_token_to_piece(
    model: *const llama_model,
    token: llama_token,
    buf: *mut c_char,
    length: i32
) -> i32
{
    llama_token_to_piece(
        model,
        token,
        buf,
        length
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_chat_apply_template(
    model: *const llama_model,
    tmpl: *const c_char,
    chat: *const llama_chat_message,
    n_msg: usize,
    add_ass: bool,
    buf: *mut c_char,
    length: i32
) -> i32
{
    llama_chat_apply_template(
        model,
        tmpl,
        chat,
        n_msg,
        add_ass,
        buf,
        length
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_grammar_init(
    rules: *mut *const llama_grammar_element,
    n_rules: usize,
    start_rule_index: usize
) -> *mut llama_grammar
{
    llama_grammar_init(
        rules,
        n_rules,
        start_rule_index
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_grammar_free(
    grammar: *mut llama_grammar
)
{
    llama_grammar_free(
        grammar
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_grammar_copy(
    grammar: *const llama_grammar
) -> *mut llama_grammar
{
    llama_grammar_copy(
        grammar
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_set_rng_seed(
    ctx: *mut llama_context,
    seed: u32
)
{
    llama_set_rng_seed(
        ctx,
        seed
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_repetition_penalties(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    last_tokens: *const llama_token,
    penalty_last_n: usize,
    penalty_repeat: f32,
    penalty_freq: f32,
    penalty_present: f32
)
{
    llama_sample_repetition_penalties(
        ctx,
        candidates,
        last_tokens,
        penalty_last_n,
        penalty_repeat,
        penalty_freq,
        penalty_present
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_apply_guidance(
    ctx: *mut llama_context,
    logits: *mut f32,
    logits_guidance: *mut f32,
    scale: f32
)
{
    llama_sample_apply_guidance(
        ctx,
        logits,
        logits_guidance,
        scale
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_softmax(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array
)
{
    llama_sample_softmax(
        ctx,
        candidates
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_top_k(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    k: i32,
    min_keep: usize
)
{
    llama_sample_top_k(
        ctx,
        candidates,
        k,
        min_keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_top_p(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    p: f32,
    min_keep: usize
)
{
    llama_sample_top_p(
        ctx,
        candidates,
        p,
        min_keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_min_p(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    p: f32,
    min_keep: usize
)
{
    llama_sample_min_p(
        ctx,
        candidates,
        p,
        min_keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_tail_free(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    z: f32,
    min_keep: usize
)
{
    llama_sample_tail_free(
        ctx,
        candidates,
        z,
        min_keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_typical(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    p: f32,
    min_keep: usize
)
{
    llama_sample_typical(
        ctx,
        candidates,
        p,
        min_keep
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_entropy(
    ctx: *mut llama_context,
    candidates_p: *mut llama_token_data_array,
    min_temp: f32,
    max_temp: f32,
    exponent_val: f32
)
{
    llama_sample_entropy(
        ctx,
        candidates_p,
        min_temp,
        max_temp,
        exponent_val
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_temp(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    temp: f32
)
{
    llama_sample_temp(
        ctx,
        candidates,
        temp
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_grammar(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    grammar: *const llama_grammar
)
{
    llama_sample_grammar(
        ctx,
        candidates,
        grammar
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_token_mirostat(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    tau: f32,
    eta: f32,
    m: i32,
    mu: *mut f32
) -> llama_token
{
    llama_sample_token_mirostat(
        ctx,
        candidates,
        tau,
        eta,
        m,
        mu
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_token_mirostat_v2(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array,
    tau: f32,
    eta: f32,
    mu: *mut f32
) -> llama_token
{
    llama_sample_token_mirostat_v2(
        ctx,
        candidates,
        tau,
        eta,
        mu
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_token_greedy(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array
) -> llama_token
{
    llama_sample_token_greedy(
        ctx,
        candidates
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_sample_token(
    ctx: *mut llama_context,
    candidates: *mut llama_token_data_array
) -> llama_token
{
    llama_sample_token(
        ctx,
        candidates
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_grammar_accept_token(
    ctx: *mut llama_context,
    grammar: *mut llama_grammar,
    token: llama_token
)
{
    llama_grammar_accept_token(
        ctx,
        grammar,
        token
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_beam_search(
    ctx: *mut llama_context,
    callback: llama_beam_search_callback_fn_t,
    callback_data: *mut c_void,
    n_beams: usize,
    n_past: i32,
    n_predict: i32
)
{
    llama_beam_search(
        ctx,
        callback,
        callback_data,
        n_beams,
        n_past,
        n_predict
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_split_path(
    split_path: *mut c_char,
    maxlen: usize,
    path_prefix: *const c_char,
    split_no: c_int,
    split_count: c_int
) -> c_int
{
    llama_split_path(
        split_path,
        maxlen,
        path_prefix,
        split_no,
        split_count
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_split_prefix(
    split_prefix: *mut c_char,
    maxlen: usize,
    split_path: *const c_char,
    split_no: c_int,
    split_count: c_int
) -> c_int
{
    llama_split_prefix(
        split_prefix,
        maxlen,
        split_path,
        split_no,
        split_count
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_get_timings(
    ctx: *mut llama_context
) -> llama_timings
{
    llama_get_timings(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_print_timings(
    ctx: *mut llama_context
)
{
    llama_print_timings(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_reset_timings(
    ctx: *mut llama_context
)
{
    llama_reset_timings(
        ctx
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_print_system_info(

) -> *const c_char
{
    llama_print_system_info(

    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_log_set(
    log_callback: ggml_log_callback,
    user_data: *mut c_void
)
{
    llama_log_set(
        log_callback,
        user_data
    )
}

#[no_mangle]
pub unsafe extern "C" fn csbindgen_llama_dump_timing_info_yaml(
    stream: *mut FILE,
    ctx: *const llama_context
)
{
    llama_dump_timing_info_yaml(
        stream,
        ctx
    )
}

    